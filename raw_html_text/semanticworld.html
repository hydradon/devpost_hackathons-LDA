<html>
    <head>
    </head>
    <body>
        <div class="large-9 columns" id="app-details-left">
            <div id="gallery">
                <ul>
                    <li class="text-center">
                        <a data-lightbox="403123" data-title="Libraries used by the program: Apache Spark, Stanford CoreNLP, and MIT Java Interface to the Princeton WordNet Lexical Database" href="https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/403/123/datas/original.png">
                            <img alt="SemanticWorld &ndash; screenshot 1" class="software_photo_image image-replacement" onerror="this.onerror=null;this.src='https://devpost-challengepost.netdna-ssl.com/assets/defaults/thumbnail-placeholder-42bcab8d8178b413922ae2877d8b0868.gif';" src="//challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/403/123/datas/gallery.jpg">
                        </a>
                        <span class="expand-tag">
                            <i class="fas fa-expand">
                            </i>
                        </span>
                        <p>
                            <i>
                                Libraries used by the program: Apache Spark, Stanford CoreNLP, and MIT Java Interface to the Princeton WordNet Lexical Database
                            </i>
                        </p>
                    </li>
                    <li class="text-center">
                        <a data-lightbox="403121" data-title='A sample business insights, using: sbt "run -b \"Mon Ami Gabi\""' href="https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/403/121/datas/original.png">
                            <img alt="SemanticWorld &ndash; screenshot 2" class="software_photo_image image-replacement" onerror="this.onerror=null;this.src='https://devpost-challengepost.netdna-ssl.com/assets/defaults/thumbnail-placeholder-42bcab8d8178b413922ae2877d8b0868.gif';" src="//challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/403/121/datas/gallery.jpg">
                        </a>
                        <span class="expand-tag">
                            <i class="fas fa-expand">
                            </i>
                        </span>
                        <p>
                            <i>
                                A sample business insights, using: sbt "run -b \"Mon Ami Gabi\""
                            </i>
                        </p>
                    </li>
                </ul>
            </div>
            <div>
                <h2>
                    Inspiration
                </h2>
                <p>
                    According to the U.S. Government:
                </p>
                <pre class="language-nolang"><code>https://www.sba.gov/sites/default/files/FAQ_Sept_2012.pdf

Small businesses make up: 99.7 percent of U.S. employer firms, 64 percent 
of net new private-sector jobs,
</code></pre>
                <p>
                    and according to the U.S. Small Business &amp; Entrepreneurship Council,
                </p>
                <pre class="language-nolang"><code>http://sbecouncil.org/about-us/facts-and-data/

In 2012, according to U.S. Census Bureau data, there were 5.73 million employer
firms in the U.S. Firms with fewer than 500 workers accounted for 99.7 percent 
of those businesses, and businesses with less than 20 workers made up 89.6 
percent. Add in the number of nonemployer businesses &ndash; there were 23.0 million 
in 2013 &ndash; then the share of U.S. businesses with less than 20 workers increases 
to 97.9 percent.
</code></pre>
                <p>
                    It is very important to know how technologies like
                    <strong>
                        Apache Spark
                    </strong>
                    can be used in the sphere of small businesses, since they represent 99.7 percent of U.S. employer firms, and have so much weight in the employment rate in the U.S. and thereafter, in society. Of course, Apache Spark can be as well used in big corporations.
                </p>
                <p>
                    There are many projects with Apache Spark that are able to analyze numerical data fast and with a very high level of precision. An example of one of those projects is, e.g.,
                </p>
                <pre class="language-nolang"><code>https://github.com/je-nunez/apache_spark
</code></pre>
                <p>
                    which does a segmentation analysis (K-Means clustering) on the numerical data provided by the
                    <strong>
                        2014 Housing Survey
                    </strong>
                    from
                    <strong>
                        The Center for Microeconomic Data of the Federal Reserve Bank of New York
                    </strong>
                    . (This numerical data, in the input format of an Excel spreadsheet and available here:
                    <a href="https://www.newyorkfed.org/medialibrary/interactives/sce/sce/downloads/data/FRBNY-SCE-Housing-Module-Public-Microdata-Complete.xlsx" rel="nofollow">
                        https://www.newyorkfed.org/medialibrary/interactives/sce/sce/downloads/data/FRBNY-SCE-Housing-Module-Public-Microdata-Complete.xlsx
                    </a>
                    , is an example of the numerical data that Apache Spark can process, and even to higher scale to that provided in that survey of The Center for Microeconomic Data of the Federal Reserve Bank of New York.)
                </p>
                <p>
                    Apache Spark excels in analyzing multiple-dimensions of numerical data, doing numerical regressions, or mixed with categorical dimensions, doing classifications. As well, as shown in the paragraph below, clustering. It is a very capable Machine Learning Library, with Generalized Linear Regression, Logistic Regression, Random Forests, MultiLayer Perceptrons (MLPs), etc.
                </p>
                <p>
                    But this competition is about Apache Spark applied to businesses and the economy. On one hand, I, as an outsider to the business field, do not possess a big numerical dataset with detailed business operations in multiple dimensions, on which Apache Spark easily will excel. (I'm thinking in numerical datasets like the ones that can be obtained from
                    <strong>
                        Six-Sigma Quality
                    </strong>
                    assurance, or
                    <strong>
                        Total-Quality-Management
                    </strong>
                    , because these very detailed numerical datasets are internal to the company that feeds and owns them. I.e., these numerical, business operations, datasets are private.)
                </p>
                <p>
                    On the other hand, Apache Spark is not restricted to numerical (multi-dimensional) data, and, for small businesses, the main data is simple
                    <strong>
                        English text in the manner of business reviews
                    </strong>
                    , like in the Yelp dataset. For this, Spark is able to easily accommodate into its engine other very important systems like the
                    <strong>
                        Stanford CoreNLP
                    </strong>
                    library, and the
                    <strong>
                        MIT Java Interface to the Princeton WordNet Lexical Database
                    </strong>
                    . Spark is able to integrate its data to syntactic analysis executed by Stanford CoreNLP and semantic analysis done the MIT Java Interface to Princeton WordNet.
                </p>
                <h2>
                    What it does
                </h2>
                <p>
                    (I wanted to do a Graphical User Interface for the program, but it would have taken me time from Apache Spark, where is were I put most of my effort, and the other libraries used here. Besides, to add a GUI over this functionality, now that it works, doesn't seem to be complicated since the workload is taken mainly by Apache Spark, not a custom UI, which the program doesn't depend upon.)
                </p>
                <p>
                    This program has two different ways of running.
                </p>
                <p>
                    One is to get business insights for a given business in the Yelp academic database, using its
                    <strong>
                        -b
                    </strong>
                    option. For example:
                </p>
                <pre class="language-nolang"><code>     sbt "run -b \"Earl of Sandwich\""
</code></pre>
                <p>
                    It will do a syntactical and semantical analysis of the Yelp reviews for that business and produce a report like this:
                </p>
                <pre class="language-nolang"><code>     compound: roast beef (occurrences: 149)
                    compound: tomato soup (occurrences: 113)
     amod: best sandwich (occurrences: 79)
     amod: full montagu (occurrences: 64)
     amod: long line (occurrences: 62)
     amod: long lines (occurrences: 20)
     amod: full montague (occurrences: 15)
     dobj: get montagu (occurrences: 11)
</code></pre>
                <p>
                    so we know that, for
                    <em>
                        Earl of Sandwich
                    </em>
                    , people were recommending specifically their
                    <em>
                        roast beef
                    </em>
                    ,
                    <em>
                        tomato soup
                    </em>
                    , and the
                    <em>
                        full montagu
                    </em>
                    , and they were complaining about
                    <em>
                        long lines
                    </em>
                    . These insights are meaningful for the (small) business owner, because they summarize what people do appreciate of the business, and more, than these summaries are shorter than reading each review one by one. E.g., the
                    <em>
                        Earl of Sandwich
                    </em>
                    has 1957 5-stars reviews only, so reading them is time consuming, and probably a small business owner does not have time for reading them all. (As a side note, Yelp indicates that Earl of Sandwich -Las Vegas- has 4.5 stars average stars out of 5 maximum, and it is taken as an example here. I am not associated to that company nor have ever visited this business.)
                </p>
                <p>
                    For example, in the image above in this page, it is seen the heading of the insights on another business,
                    <em>
                        Mon Ami Gabi
                    </em>
                    in Las Vegas (again, the argument to the
                    <strong>
                        -b
                    </strong>
                    option must be the
                    <strong>
                        exact
                    </strong>
                    business name as it appears in Yelp -this can be solved in the next version of the project):
                </p>
                <pre class="language-nolang"><code>       sbt "run -b \"Mon Ami Gabi\""
</code></pre>
                <p>
                    where it can be seen that the preferences of the Yelp reviewers are:
                </p>
                <pre class="language-nolang"><code>       compound: onion soup (occurrences: 174)
                            amod: great view (occurrences: 101)
       amod: next time (occurrences: 96)
       amod: filet mignon (occurrences: 95)
       compound: water show (occurrences: 91)
       compound: fountain show (occurrences: 91)
       amod: great service (occurrences: 81)
       amod: french soup (occurrences: 81)
       compound: steak frites (occurrences: 74)
       compound: goat cheese (occurrences: 71)
</code></pre>
                <p>
                    The second way to run this program is with the
                    <strong>
                        -c
                    </strong>
                    option, like:
                </p>
                <pre class="language-nolang"><code>   sbt "run -c sandwich"
</code></pre>
                <p>
                    where it will try to find and rank the businesses in the Yelp database according as they provide
                    <em>
                        sandwich
                    </em>
                    or an
                    <strong>
                        hypernym
                    </strong>
                    of the word
                    <em>
                        sandwich
                    </em>
                    (e.g.,
                    <em>
                        snack_food
                    </em>
                    ). (An hypernym is the word whose meaning includes the meanings of other words, like the hypernym
                    <em>
                        snack_food
                    </em>
                    includes
                    <em>
                        sandwich
                    </em>
                    . The usefulness of hypernyms is that they offer an alternative -although with lower rank- if the main desire is not available in a geographical location. See below for more.) In general, the argument to pass to the
                    <strong>
                        -c
                    </strong>
                    option is what the customer is looking for. (In the example here, it was written that
                    <em>
                        sandwich
                    </em>
                    is what the customer is looking for.)
                </p>
                <h2>
                    How I built it
                </h2>
                <p>
                    This program has been written in Scala (and compiled for Scala version 2.10.6, Apache Spark version 1.6.2).
                </p>
                <p>
                    Apache Spark is able to import data from different sources and databases, and MongoDB is a good document database. So the Yelp academic dataset is imported into MongoDB, from which Apache Spark reads the business reviews and companies information.
                </p>
                <p>
                    This program defines a
                    <strong>
                        User-Defined-Function
                    </strong>
                    (UDF) to be run inside Apache Spark, and this UDF does a syntactic parsing of the text of the Yelp reviews using Stanford CoreNLP. It then uses the Part-Of-Speech (noun, adjective, verb, adverb, preposition, etc.) and the dependency parse tree that the syntactical analysis found, and passes some of them to the semantic analysis using the MIT Java Interface to Princeton WordNet. WordNet then finds the stems of the words and the lemmas, which then are returned by this Spark user-defined function and saved by Spark in a new dataframe.
                </p>
                <p>
                    The semantic part is used mainly for the satisfaction of a specific customer's desire,
                </p>
                <pre class="language-nolang"><code>        sbt "run -c sandwiches"
</code></pre>
                <p>
                    because this semantic part does not do an exact string search. It takes the stem and lemma of the desire (in this case it would calculate that it is
                    <em>
                        sandwich
                    </em>
                    in singular), and then, using the semantical
                    <strong>
                        hypernyms
                    </strong>
                    of that word (e.g.,
                    <em>
                        snack_food
                    </em>
                    , according to Princeton WordNet), will try to do a ranked matching of these terms in the Spark dataframe. I.e., if any semantic lemma in a Yelp review in the Spark dataframe matches the lemma of the desire requested, then it has a ranking value of
                    <em>
                        1.0
                    </em>
                    . But if there is no direct match between the lemmas, then it tries to find if there is a match between the
                    <em>
                        hypernyms
                    </em>
                    of the business review and what the customer is currently desiring (e.g., in our example, if there is no exact match on the lemma
                    <em>
                        sandwich
                    </em>
                    , then it tries to find a match between the hypernyms
                    <em>
                        snack_food
                    </em>
                    ), but if the hypernyms do intersect, then the ranking value is not 1.0, as in the case before an exact match of the real lemmas, but some ranking value between 0.0 and 1.0, and lesser than 1.0. This allows the program to say
                    <em>
                        "hey, it doesn't seem that there are sandwich places around, but there is a very good snack_food place, with excellent reviews, that perhaps you are interested in visiting"
                    </em>
                    . Of course, as already said, the ranking value of a match on a semantic hypernym is less than 1.0, that is the ranking value of an exact match of the original, simple lemma requested.
                </p>
                <h2>
                    Challenges I ran into
                </h2>
                <p>
                    The first challenge was that the original version did not use CoreNLP nor WordNet, only tokenized the sentences into N-Grams of length between 1 and 6 words long, and did a topic (aspect) analysis of these N-Grams with a term frequency-inverse document frequency (TF-IDF), to see which N-Grams were more relevant, capturing more information. But a hashing Spark does in
                    <em>
                        HashingTF
                    </em>
                    is currently with
                    <em>
                        private
                    </em>
                    accessor in Scala, so it was able to calcula
                    <em>
                        privately
                    </em>
                    the TF-IDF of a word or N-Gram, but not to give which is the hashing value of an explicit word or N-Gram given by the user. Apache Spark is open-source, so I was able to find this hashing and incorporate in the UDF to select the most relevant words or N-Grams.
                </p>
                <p>
                    The second challenge was that, while this first version worked and gave insights, it was realized that if it knew which English words in the reviews were acting as nouns, which as adjectives, and other parts-of-the-speech, then their efficacy of their insights would increase. For this, the Stanford CoreNLP natural language processing library was introduced into this project to find the Part-Of-Speech of each word acts in a sentence. Apache Spark worked nicely with a User-Defined-Function that used Stanford CoreNLP.
                </p>
                <p>
                    A third challenge was the Apache Spark released a new version, 2.0.0, on July 26th, that it was tried to be used, but the current version of the MongoDB connector for Spark only works with Spark version 1.6.x, it hasn't been updated yet in this month to work with Spark 2.0.0.
                </p>
                <p>
                    The final challenge was the business relevance of this program. A simple English word, like
                    <em>
                        soup
                    </em>
                    , may give insight to a business owner, but if it is a compound word a reviewer has written, like
                    <em>
                        tomato soup
                    </em>
                    , or
                    <em>
                        cranberry sauce
                    </em>
                    , or
                    <em>
                        Hawaiian BBQ
                    </em>
                    ,
                    <em>
                        chicken avocado
                    </em>
                    , etc., or with adjectives,
                    <em>
                        long line
                    </em>
                    ,
                    <em>
                        best sandwich
                    </em>
                    , etc., it gives greater insight to him. For this, the dependency tree-parser of Stanford CoreNLP was introduced in the Spark User-Defined-Function, and in order that a customer could request any desire to the program without using exact matches but semantical (hypernym) matches, the MIT Interface to the Princeton WordNet Lexical Database was introduced into the Spark UDF as well.
                </p>
                <h2>
                    Accomplishments that I'm proud of
                </h2>
                <p>
                    The combination of Apache Spark, MongoDB, Stanford CoreNLP, and the MIT JWI Interface to Princeton WordNet worked in a User-Defined-Function inside Spark.
                </p>
                <p>
                    The program is able to give business insights given the Yelp reviews, like the ones above for the business
                    <em>
                        Earl of Sandwich
                    </em>
                    .
                </p>
                <h2>
                    What I learned
                </h2>
                <p>
                    I learned the three of them, Apache Spark, Stanford CoreNLP and MIT/Princeton WordNet. The first I knew something, but not at this level. Of the others two, I didn't know about them.
                </p>
                <p>
                    I witnessed how powerful, stable, fast and extensible Apache Spark is. How Stanford CoreNLP and MIT/Princeton WordNet advance the field of natural language processing.
                </p>
                <h2>
                    What's next for SemanticWorld
                </h2>
                <p>
                    Make the option of satisfying a customer's desire faster. The issue is that the it is searching the entire Yelp academic database, which is big and has businesses all over the country, to calculate the ranking of each business reviewed in Yelp and see which are the businesses that satisfy that desire -although the business be in other side of the country. This is unnecessary. To solve this issue, a geographical location query to MongoDB can be given, i.e., analyze only those businesses which are within a certain distance from a geolocation. Two command-line options can be given to the program,
                    <strong>
                        --latitude
                    </strong>
                    and
                    <strong>
                        --longitude
                    </strong>
                    , to restrict the search to this geographical neighbourhood only. (Yelp does have in its database the exact latitude and longitude of each business in the review.) This can be done with MongoDB's geospatial query, explained here
                    <a href="https://docs.mongodb.com/manual/reference/operator/query-geospatial/" rel="nofollow">
                        https://docs.mongodb.com/manual/reference/operator/query-geospatial/
                    </a>
                    .
                </p>
                <p>
                    Another enhancement is to gather a longer combination of related words because they can give greater business insight. So far it is using two words, which is good, but perhaps three could be better. (On the other hand, for summarizing information in a short time to a business owner, two words might be more efficacious than three.) But for doing three-words phrases, subtrees comprehension in the dependency parse tree given by Stanford CoreNLP are necessary. To do this is possible, but requires the analysis of more cases for their relevance, e.g., when a subtree is an adjective and a noun, and the other subtree is a verb and that same noon, then: when this longer subtree with three words is relevant and when isn't? does it matter if the position of the verb is before or after the adjective? These are cases to analyze.
                </p>
                <p>
                    Another interest is the use of custom
                    <strong>
                        Named Entity Taggers
                    </strong>
                    (NERs) in Stanford CoreNLP. These are annotations that can give insight as well, but are local domains of expertise. (I.e., NERs are like private data dimensions defined by each business for its internal use, they are not like the hypernyms in Princeton WordNet, which apply to all the usual English language.) Stanford CoreNLP NERs are useful because they can allow each business to define their own data dimensions over the text of the review.
                </p>
            </div>
            <div class="" id="built-with">
                <h2>
                    Built With
                </h2>
                <ul class="no-bullet inline-list">
                    <li>
                        <span class="cp-tag">
                            apache-spark
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag">
                            mit-jwi
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/mongodb">
                                mongodb
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag">
                            princeton-wordnet
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/scala">
                                scala
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag">
                            stanford-corenlp
                        </span>
                    </li>
                </ul>
            </div>
            <nav class="app-links section">
                <h2>
                    Try it out
                </h2>
                <ul class="no-bullet" data-role="software-urls">
                    <li>
                        <a href="https://bitbucket.org/je-nunez/semanticworld/" rel="nofollow" target="_blank" title="https://bitbucket.org/je-nunez/semanticworld/">
                            <i class="ss-icon ss-link">
                            </i>
                            <span>
                                bitbucket.org
                            </span>
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </body>
</html>
