<html>
    <head>
    </head>
    <body>
        <div class="large-9 columns" id="app-details-left">
            <div id="gallery">
                <ul>
                    <li class="text-center">
                        <a data-lightbox="461145" href="https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/461/145/datas/original.jpg">
                            <img alt="107 - GPU Wiki Rules Miner &ndash; screenshot 1" class="software_photo_image image-replacement" onerror="this.onerror=null;this.src='https://devpost-challengepost.netdna-ssl.com/assets/defaults/thumbnail-placeholder-42bcab8d8178b413922ae2877d8b0868.gif';" src="//challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/461/145/datas/gallery.jpg">
                        </a>
                        <span class="expand-tag">
                            <i class="fas fa-expand">
                            </i>
                        </span>
                        <p>
                            <i>
                            </i>
                        </p>
                    </li>
                </ul>
            </div>
            <div>
                <h2>
                    Inspiration
                </h2>
                <p>
                    Recent years, knowledge bases like Wikidata and Freebase have grown rapidly. These knowledge bases are valuable data sources for many different purposes. One of the purposes of knowledge bases is to serve as training dataset for machine learning, especially in rule inference areas. Well-known research areas include rule inference based on markov logic network and inductive logic programming. However, these methods are all under closed world assumption. Our knowledge base is naturally under open world assumption that un-exhibited facts are not necessarily correct. Another challenge here is that the size of present knowledge base is extremely large. We want to find a way of mining rules and revealing relationships among given keywords.
                </p>
                <h2>
                    What it does
                </h2>
                <p>
                    The input is set of keywords. And our wiki-rule-miner would return frequent chains of rule patterns from Wikidata knowledge base. These chain of rules will connect given keywords and reveal their underlying relationships. However, due to limited time and capacity of our hardware, we have implement just a prototype, which can mine a small part of Wikidata graph.
                </p>
                <h2>
                    How we built it
                </h2>
                <p>
                    We use Wikidata toolkit to extract all nodes and edges from the Wiki graph. The graph data is preprocessed in Python.
                </p>
                <p>
                    Subsequently, we use GPU to count frequent rule patterns. These rules are all horn clauses and we set a language bias such that the length of rules can never extend 3, which follows the principle of Occam's razor.
                </p>
                <h2>
                    Challenges we ran into
                </h2>
                <p>
                    Out major struggle was in preprocessing the large dataset, hard text processing, and a need to come up with a parallel model to count frequent rule patterns on gpu. For GPU part, we have to make memory acces aligned and make sure every thread is doing the right thing while traversing the graph.
                </p>
                <h2>
                    Accomplishments that we're proud of
                </h2>
                <p>
                    In 24 hours, we have implemented, from ground, the extractiong and preprocessing cpu part and the traversing and counting part on gpu.
                </p>
                <h2>
                    What we learned
                </h2>
                <p>
                    We have learned that text processing and gpu coding are so hard, especially in the debugging phase. These task are difficult because the data volume is too large. And a lot of unexpected text errors just appear endless.
                </p>
                <p>
                    For gpu part, we invent a map-reduce method to traverse and count frequent patterns. Each node in the graph is an entity and has a label or type. For instance, a person would have the type attribute human. Thus, the pattern for the node is human. And there can be of lot of entities nodes that have type human. Our traverse expands in execute, for each pattern we map it to different patterns after extending paths under that pattern. And then we reduce paths with same pattern into one pattern, meanwhile count the occurances of this patterns, which is equivalent to the number of concrete paths the pattern has. We keep map and reduce until we connect all keyword. 
To come up with this algoriothm is a huge challenge.
                </p>
                <h2>
                    What's next for 107 - GPU Wiki Rules Miner
                </h2>
                <p>
                    We will optimize our prototype of wiki-rule-miner, make it more scalable and efficient. If we can find enough computing resources, we may try to make the computation task across multi-gpu.
                </p>
            </div>
            <div class="" id="built-with">
                <h2>
                    Built With
                </h2>
                <ul class="no-bullet inline-list">
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/c--3">
                                c++
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag">
                            cuda
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/python">
                                python
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag">
                            thrust
                        </span>
                    </li>
                </ul>
            </div>
        </div>
    </body>
</html>
