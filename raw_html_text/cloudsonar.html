<html>
    <head>
    </head>
    <body>
        <div class="large-9 columns" id="app-details-left">
            <div id="gallery">
                <ul>
                    <li>
                        <div class="flex-video">
                            <iframe allowfullscreen="allowfullscreen" allowscriptaccess="always" class="video-embed" frameborder="0" height="371" mode="transparent" src="https://www.youtube.com/embed/9OKGz4p-P6g?enablejsapi=1&amp;hl=en_US&amp;rel=0&amp;version=3&amp;wmode=transparent" type="text/html" webkitallowfullscreen="true" width="660" wmode="transparent">
                            </iframe>
                        </div>
                    </li>
                </ul>
            </div>
            <div>
                <h2>
                    Inspiration
                </h2>
                <p>
                    The critical event any IT service provider cares is a service outage(e.g. HTTP 5xx response). But there are just too many variables. uptime, Java gc counts/time, CPU, I/O util, swap memory usage, etc.
                </p>
                <p>
                    Whenever you try to detect a service outage before it happens, you get screwed up by those countless variables.
                </p>
                <p>
                    One day, I noticed Apache Cassandra uses a very simple metrics to detect a node failure, which is based on the following theory.
                </p>
                <p>
                    <a href="http://www.jaist.ac.jp/%7Edefago/files/pdf/IS_RR_2004_010.pdf" rel="nofollow">
                        http://www.jaist.ac.jp/~defago/files/pdf/IS_RR_2004_010.pdf
                    </a>
                </p>
                <p>
                    This inspired me to try HTM against simple PING response times to predict possible high load that could generate an error.
                </p>
                <h2>
                    What it does
                </h2>
                <p>
                    It polls a given set of nodes by PING periodically. Then, record its response times, and which are fed to PhiFailureDetector and HTMAnomalyDetector to detect an important event to watch out.
                </p>
                <p>
                    Please refer to
                    <a href="https://github.com/ggsato/CloudSonar#concept" rel="nofollow">
                        Concept
                    </a>
                    on my project for details.
                </p>
                <h3>
                    Case Study
                </h3>
                <p>
                    The case study I have investigated was done on a 6 nodes Cloudian HyperStore(S3 object storage) cluster. You can simply think of it as a distributed file system with a web interface. All the HTTP requests were routed to cloudian-node1, then distributed among 6 storage services.
                </p>
                <p>
                    The traffic pattern I used was a constantly high traffic for this cluster, which would produce an error if some more requests had been added.
                </p>
                <p>
                    <img alt="traffic pattern" data-canonical-url="https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/traffic_pattern.png" src="https://res.cloudinary.com/devpost/image/fetch/s--jZznhppk--/c_limit,f_auto,fl_lossy,q_auto:eco,w_900/https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/traffic_pattern.png">
                </p>
                <p>
                    To make it overloaded, a temporal random traffic surge was added every hour. Then, as expected, 6 errors were observed as follows.
                </p>
                <p>
                    <img alt="http statuses" data-canonical-url="https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/http_responses.png" src="https://res.cloudinary.com/devpost/image/fetch/s--wdnsTLWY--/c_limit,f_auto,fl_lossy,q_auto:eco,w_900/https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/http_responses.png">
                </p>
                <p>
                    Now, the first question is if this tool could have provided a useful information based on anomaly score by HTM before they happened.
                </p>
                <p>
                    The followings are examples against node1 taken on node3.
                </p>
                <p>
                    HTM inputs, log10 of response time in micro seconds, looked like this.
                </p>
                <p>
                    <img alt="log10 of response time in micro seconds" data-canonical-url="https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/log10_response_timeseries.png" src="https://res.cloudinary.com/devpost/image/fetch/s--2wvGI8Pt--/c_limit,f_auto,fl_lossy,q_auto:eco,w_900/https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/log10_response_timeseries.png">
                </p>
                <p>
                    This looks there is no direct indication of such an error. For example, around 6:50, there were 4 503 errors. But no particular spike there. There could be a hidden pattern, but may be not. Let's see.
                </p>
                <p>
                    And this is the distribution. 2.5 is around 300 micro seconds.
                </p>
                <p>
                    <img alt="the distribution of log10 response time in micro seconds" data-canonical-url="https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/log10_response_distribution.png" src="https://res.cloudinary.com/devpost/image/fetch/s--2TR7P-v3--/c_limit,f_auto,fl_lossy,q_auto:eco,w_900/https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/log10_response_distribution.png">
                </p>
                <p>
                    PhiFailureDetector shows a server health. It is below 1.0, if it is fine. The lower, the better. You can set a horizontal line(threshold) to identify a bad node.
                </p>
                <p>
                    Here, as you can see, there are so many high values over 1.0. Some spikes are even beyond 10(0.0000001%). This indicates that the server was under high load.
                </p>
                <p>
                    A PHI value is a good indication of server health, but simply lowering a threshold doesn't really help. For example, if you would set 2.0, the first alarm could have been given around 22:10, followed by many more alerts. You may try 5.0 to avoid too many alarms. But you still have no idea if this is OK or not.
                </p>
                <p>
                    <img alt="phi time series" data-canonical-url="https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/phi_timeseries.png" src="https://res.cloudinary.com/devpost/image/fetch/s--FhUKE-Tg--/c_limit,f_auto,fl_lossy,q_auto:eco,w_900/https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/phi_timeseries.png">
                </p>
                <p>
                    HTMAnomalyDetector allows you to see a vertical line instead of a horizontal line(threshold), which indicates an anomaly, the time when unexpected pattern was observed against its prediction(max in the next 30 seconds).
                </p>
                <p>
                    As you can see, HTM detected whenever a pattern has changed.
                </p>
                <p>
                    <img alt="anomaly detector" data-canonical-url="https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/anomaly_max30.png" src="https://res.cloudinary.com/devpost/image/fetch/s--UGqnUyTr--/c_limit,f_auto,fl_lossy,q_auto:eco,w_900/https://raw.githubusercontent.com/ggsato/CloudSonar/master/resources/images/anomaly_max30.png">
                </p>
                <h3>
                    Conclusion
                </h3>
                <p>
                    Cloud Sonar is not an oracle, so can not tell when an error could happen. But Cloud Sonar is confirmed that it can give an anomaly whenever a pattern changes.
                </p>
                <p>
                    If you look back a pattern when your server got overloaded, then you'll see the first point that became higher than its usual pattern. And it must be the first possible point you could be notified.
                </p>
                <p>
                    So, the best way to deal with an unexpected event is to know as soon as possible when a change is observed. And it is what Cloud Sonar can provide.
                </p>
                <h2>
                    How I built it
                </h2>
                <p>
                    Using HTM.java, and Swarming to find optimal configurations.
                </p>
                <h2>
                    Challenges I ran into
                </h2>
                <ul>
                    <li>
                        <p>
                            HTM parameter tunings.
                            <br>
                            =&gt; Let Swarming find
                            <br>
                            ==&gt; Takes long...
                        </p>
                    </li>
                    <li>
                        <p>
                            HTM input scale.
                        </p>
                    </li>
                </ul>
                <h2>
                    Accomplishments that I'm proud of
                </h2>
                <p>
                    A very simple method to monitor a server health, and detect an anomaly.
                </p>
                <h2>
                    What I learned
                </h2>
                <p>
                    I have tried to collect more and more features. But an important simple value contains so many information. The hardest part is how to find it, and extract valuable information out of it.
                </p>
                <h2>
                    What's next for CloudSonar
                </h2>
                <ol>
                    <li>
                        more patterns like daily/weekly/monthly/holiday/seasonal
                        <br>
                        ==&gt; the result will be presented at Data Tech conference in Dec. at Tokyo
                    </li>
                    <li>
                        serialization (contribution to htm.java)
                    </li>
                    <li>
                        flume/fluentd appender to upload csv files to S3 storage for analytics
                    </li>
                </ol>
            </div>
            <div class="" id="built-with">
                <h2>
                    Built With
                </h2>
                <ul class="no-bullet inline-list">
                    <li>
                        <span class="cp-tag">
                            htm.java
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/java">
                                java
                            </a>
                        </span>
                    </li>
                </ul>
            </div>
            <nav class="app-links section">
                <h2>
                    Try it out
                </h2>
                <ul class="no-bullet" data-role="software-urls">
                    <li>
                        <a href="https://github.com/ggsato/CloudSonar" rel="nofollow" target="_blank" title="https://github.com/ggsato/CloudSonar">
                            <i class="ss-icon ss-link">
                            </i>
                            <span>
                                github.com
                            </span>
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </body>
</html>
