<html>
    <head>
    </head>
    <body>
        <div class="large-9 columns" id="app-details-left">
            <div id="gallery">
                <ul>
                    <li class="text-center">
                        <a data-lightbox="620207" data-title="CoopLevel" href="https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/620/207/datas/original.jpg">
                            <img alt="CanYouDoWhatICanDo &ndash; screenshot 1" class="software_photo_image image-replacement" onerror="this.onerror=null;this.src='https://devpost-challengepost.netdna-ssl.com/assets/defaults/thumbnail-placeholder-42bcab8d8178b413922ae2877d8b0868.gif';" src="//challengepost-s3-challengepost.netdna-ssl.com/photos/production/software_photos/000/620/207/datas/gallery.jpg">
                        </a>
                        <span class="expand-tag">
                            <i class="fas fa-expand">
                            </i>
                        </span>
                        <p>
                            <i>
                                CoopLevel
                            </i>
                        </p>
                    </li>
                </ul>
            </div>
            <div>
                <h2>
                    Inspiration
                </h2>
                <p>
                    The inspiration comes from a Japanese game show:
                    <a href="https://www.youtube.com/watch?v=zL4HSk4MUUw" rel="nofollow">
                        https://www.youtube.com/watch?v=zL4HSk4MUUw
                    </a>
                    The players are standing in front of a moving wall which only has small cut outs through which the players have to squeeze through in order not to get pushed in a pool behind them.
                </p>
                <p>
                    We wanted to play this game without a massive hardware set up and easier way to create new challenges that don't require a full workshop to build the walls.
                </p>
                <h2>
                    What it does
                </h2>
                <p>
                    The installation records the pose of a player with a 3d camera and uses a projector to show the current player a body pose (or a shape) that he has to achieve as close as possible. The player needs creativity and for some poses quite some sense of balance.
                </p>
                <p>
                    A game consists of multiple levels and the player loses health points in each level until she fills the given shape and held this posture for some seconds.
                </p>
                <p>
                    New levels can be create by drawing them by hand or by storing the current pose of the player so that players can challenge each other. (The reason for the project name)
                </p>
                <h2>
                    How we built it
                </h2>
                <p>
                    The camera is positioned underneath the projection area and the projector is located so that the player does not cast shadows.
                </p>
                <p>
                    We use an Asus Xtion 3D Camera and the Openni2-based ROS-Driver to capture the pointcloud data. As the camera and the projector are facing each other, an automated calibration would need artificial targets so we decided to rely on a manual calibration. The most important degree of freedom is the angle of the camera relative the floor which can be estimated in only a view tries (using interactive markers in RVIZ to define the transform).
                </p>
                <p>
                    The pointcloud is read by a C++-Node that applies the transformation into the correctly rotated frame, does a z-thresholding to suppress people standing behind the player, projects it into the xy-plane and publishes it as an image and jpeg-stream. (The jpeg-stream was needed to get the data into Processing, an approach we stopped after some hours of development due to missing computer vision functions in Processing).
                </p>
                <p>
                    The pre-processed depth-mask is then read by a python-program that contains the game logic and computes the score by comparing the current depth-mask (created by the user) with a level.
                </p>
                <p>
                    The game logic is a state-machine with these states:
                </p>
                <ul>
                    <li>
                        Waiting for Player
                    </li>
                    <li>
                        Game is played
                    </li>
                    <li>
                        Player has won
                    </li>
                    <li>
                        Player has lost
                    </li>
                </ul>
                <p>
                    Depending on the game state, UI-Interfaces like Health-Bars or messages to the player are selectively shown.
                </p>
                <p>
                    While the installation is waiting for a player, a start-screen is shown and simple task (clearly recognizable human shape) is shown. If a person is crossing the playing area, his shape is visualized and the overlapping region drawn in green so that the game idea is easy understandable even without having to read a text. The player starts a game by matching the shape so that no other interface like a button or keyboard is needed. Therefore, the installation has no physical interface which could be damaged.
                </p>
                <p>
                    If there are multiple people within the playing area when the shape is matched, a multi player match is started.
                </p>
                <p>
                    The player has a global health-level that is decreased continuously (with a grace period of some seconds after each level-start). She also has a progress-bar for each level that fills the faster the better she is matching the given shape. As soon as the progress-bar is filled up, a new level is started (or the game is won). The game ends as soon as the global health-level is at zero. Each successful level increases the health a bit again.
                </p>
                <h2>
                    Challenges we ran into
                </h2>
                <p>
                    Getting images from ROS to Processing was harder than expected and we missed basic Computer Vision functions in Processing so that we decided to remove Processing again and did all visualizations with OpenCV.
                </p>
                <h2>
                    Accomplishments that we're proud of
                </h2>
                <p>
                    Responsive system, Easily understandable, no expensive components, we are only two Computer Scientists with no design experience, but the game looks nice and is easy to understand.
                </p>
                <h2>
                    What we learned
                </h2>
                <p>
                    Processing is really limited...
                </p>
                <h2>
                    What's next for CanYouDoWhatICanDo
                </h2>
                <ul>
                    <li>
                        Full port to Raspberry Pi, so setup is independent from laptop (this would most likely reduce the framerate)
                    </li>
                    <li>
                        Automatic Calibration of the system
                    </li>
                    <li>
                        Parallel installations so that two players in different locations can play together. In this setup, the shape of the distant player is projected next to the local player so that the players have to fill shapes together, but can only communicate via pantomime.
                    </li>
                </ul>
            </div>
            <div class="" id="built-with">
                <h2>
                    Built With
                </h2>
                <ul class="no-bullet inline-list">
                    <li>
                        <span class="cp-tag">
                            3dcameras
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/c--3">
                                c++
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/linux">
                                linux
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/processing">
                                processing
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag recognized-tag">
                            <a href="https://devpost.com/software/built-with/python">
                                python
                            </a>
                        </span>
                    </li>
                    <li>
                        <span class="cp-tag">
                            ros
                        </span>
                    </li>
                </ul>
            </div>
        </div>
    </body>
</html>
