[
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792485",
        "pull_request_review_id": 237236749,
        "id": 283792485,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Mzc5MjQ4NQ==",
        "diff_hunk": "@@ -1,16 +1,16 @@\n extern crate ethereum_types;\n \n use crate::data_structure::block::Block;\n+use crate::data_structure::error::Error;\n use crate::data_structure::signed_transaction::SignedTransaction;\n use ethereum_types::H256;\n \n-pub enum Error {}\n-\n pub struct BlockGenerator {}\n \n impl BlockGenerator {\n-    pub fn generate(signed_transactions: Vec<SignedTransaction>) -> Result<Block, Error> {\n+    pub fn generate(signed_transactions: &[SignedTransaction]) -> Result<Block, Error> {",
        "path": "core/src/process/block_generator.rs",
        "position": 14,
        "original_position": 14,
        "commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "original_commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Layman's Question: What is the Pros. of using this `&Type`?",
        "created_at": "2019-05-14T13:18:24Z",
        "updated_at": "2019-05-14T13:18:25Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283792485",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792485"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283792485"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792637",
        "pull_request_review_id": 237236956,
        "id": 283792637,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Mzc5MjYzNw==",
        "diff_hunk": "@@ -25,6 +25,6 @@ pub fn entry() {\n     env::set_var(\"RUST_LOG\", \"info\");\n     env_logger::init();\n     println!(\"Hello, operator!!\");\n-    let server = get_server(Default::default()).expect(\"Unable to start rpc server.\");\n+    let server = get_server(&Default::default()).expect(\"Unable to start rpc server.\");",
        "path": "operator/src/lib.rs",
        "position": 5,
        "original_position": 5,
        "commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "original_commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "ref https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19/files#r283792485",
        "created_at": "2019-05-14T13:18:47Z",
        "updated_at": "2019-05-14T13:18:47Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283792637",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792637"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283792637"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792676",
        "pull_request_review_id": 237237008,
        "id": 283792676,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Mzc5MjY3Ng==",
        "diff_hunk": "@@ -27,7 +27,7 @@ impl Default for HttpOption {\n     }\n }\n \n-pub fn get_server(options: HttpOption) -> Result<Server, Error> {\n+pub fn get_server(options: &HttpOption) -> Result<Server, Error> {",
        "path": "operator/src/server.rs",
        "position": 5,
        "original_position": 5,
        "commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "original_commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "ref https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19/files#r283792485",
        "created_at": "2019-05-14T13:18:52Z",
        "updated_at": "2019-05-14T13:18:52Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283792676",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792676"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283792676"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283951391",
        "pull_request_review_id": 237439864,
        "id": 283951391,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Mzk1MTM5MQ==",
        "diff_hunk": "@@ -1,16 +1,16 @@\n extern crate ethereum_types;\n \n use crate::data_structure::block::Block;\n+use crate::data_structure::error::Error;\n use crate::data_structure::signed_transaction::SignedTransaction;\n use ethereum_types::H256;\n \n-pub enum Error {}\n-\n pub struct BlockGenerator {}\n \n impl BlockGenerator {\n-    pub fn generate(signed_transactions: Vec<SignedTransaction>) -> Result<Block, Error> {\n+    pub fn generate(signed_transactions: &[SignedTransaction]) -> Result<Block, Error> {",
        "path": "core/src/process/block_generator.rs",
        "position": 14,
        "original_position": 14,
        "commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "original_commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Simply put,\r\n```\r\nfn foo(t T) {  // T isn't impl Copy trait\r\n  ...\r\n}\r\nlet t = T::new()\r\nfoo(t);\r\nfoo(t); // <- compile error: use of move value\r\n```\r\n\r\n```\r\nfn foo(t &T) {\r\n  ...\r\n}\r\nlet t = T::new()\r\nfoo(&t);\r\nfoo(&t);\r\n```\r\n\r\nIn first example, Rust compiler can't know that t is immutable or mutable.\r\nIn second, Rust compiler can know.\r\n\r\nps: If T implements `Copy`, it can be compiled. But we don't copy parameters unless the structure is small enough.\r\n\r\n\r\nhttps://doc.rust-lang.org/1.27.0/book/second-edition/ch04-02-references-and-borrowing.html\r\n",
        "created_at": "2019-05-14T18:57:17Z",
        "updated_at": "2019-05-14T18:59:40Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283951391",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283951391"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r283951391"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19"
            }
        },
        "in_reply_to_id": 283792485
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284138452",
        "pull_request_review_id": 237672588,
        "id": 284138452,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDEzODQ1Mg==",
        "diff_hunk": "@@ -1,16 +1,16 @@\n extern crate ethereum_types;\n \n use crate::data_structure::block::Block;\n+use crate::data_structure::error::Error;\n use crate::data_structure::signed_transaction::SignedTransaction;\n use ethereum_types::H256;\n \n-pub enum Error {}\n-\n pub struct BlockGenerator {}\n \n impl BlockGenerator {\n-    pub fn generate(signed_transactions: Vec<SignedTransaction>) -> Result<Block, Error> {\n+    pub fn generate(signed_transactions: &[SignedTransaction]) -> Result<Block, Error> {",
        "path": "core/src/process/block_generator.rs",
        "position": 14,
        "original_position": 14,
        "commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "original_commit_id": "c9fb45639c911a765e8f57ce00ab8650c31a44c5",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Thanks.\r\n\r\nNote for myself:\r\nFunction's arg is as well an assignment of variable, and so, exactly same as the normal bind/copy explanation, the copy of large variable in heap memory causes redundant I/O overhead. In order to avoid that I/O overhead, just **moving** ownership of heap data to latest-bounded variable, then borrow-checker will make a caution **if the older variable got used after the ownership moved**. This is often regarded as **shallow copy** in other languages, but in Rust, the former variable is to be invalidated and so we call it **move**.",
        "created_at": "2019-05-15T08:23:28Z",
        "updated_at": "2019-05-15T08:34:26Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r284138452",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284138452"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19#discussion_r284138452"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/19"
            }
        },
        "in_reply_to_id": 283792485
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792760",
        "pull_request_review_id": 237237110,
        "id": 283792760,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4Mzc5Mjc2MA==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": 13,
        "original_position": 13,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "ref https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/19/files#r283792485",
        "created_at": "2019-05-14T13:19:02Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r283792760",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/283792760"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r283792760"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284233815",
        "pull_request_review_id": 237793215,
        "id": 284233815,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDIzMzgxNQ==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 69,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "1. If possible I want to confirm the visualization of `LeftProofNode { right }` and `RightProofNode { left } ` because I haven't understood what does it mean.\r\n\r\n2. What is the role of `{ left, .. }` 's `..`?\r\n  - I know `_` is often used for other languages' pattern match in order to ignore unused type parameters.",
        "created_at": "2019-05-15T12:41:05Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284233815",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284233815"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284233815"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284329189",
        "pull_request_review_id": 237916849,
        "id": 284329189,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDMyOTE4OQ==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 69,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Actually, `LeftProofNode { right }` and  `RightProofNode { left }` can be one `ProofNode { data }`. But these right and left mean the path about a leaf to root.\r\nIn PG's sum-merkle-tree, this path(maybe called merkle path) is calculated by index of leaf. So this information isn't needed. I may remove this data structure if any other requirements also don't need merkle path information.\r\nhttps://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17/files/d3369c5823a3ce4242143c343648755f5fabea47#diff-ed68232242aeed78746dc99ef92f629eR220",
        "created_at": "2019-05-15T15:54:18Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284329189",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284329189"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284329189"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        },
        "in_reply_to_id": 284233815
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284332438",
        "pull_request_review_id": 237921009,
        "id": 284332438,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDMzMjQzOA==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 69,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "> 2\r\n\r\n`..` is described in \"Ignoring variants\" of Patterns.\r\n\r\nhttps://doc.rust-lang.org/1.1.0/book/patterns.html\r\n",
        "created_at": "2019-05-15T16:01:10Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284332438",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284332438"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284332438"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        },
        "in_reply_to_id": 284233815
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284522779",
        "pull_request_review_id": 238158376,
        "id": 284522779,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDUyMjc3OQ==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,\n+        root: &Bytes,\n+    ) -> Result<ImplicitBounds, Error> {\n+        let mut path: Vec<bool> = vec![];\n+        Self::get_path(idx, inclusion_proof.len(), path.as_mut());\n+        let first_left_end = path\n+            .iter()\n+            .position(|&p| p)\n+            .map(|pos| inclusion_proof[pos].clone())\n+            .map_or(0, |n| n.get_end());\n+        let mut computed = leaf.clone();\n+        for (i, item) in inclusion_proof.iter().enumerate() {\n+            if path[i] {\n+                computed = SumMerkleNode::compute_parent(item, &computed)\n+            } else {\n+                computed = SumMerkleNode::compute_parent(&computed, item)\n+            }\n+        }\n+        let is_last_leaf = 2u64.pow(inclusion_proof.len() as u32) - 1 == (idx as u64);\n+        if computed.hash() == root {\n+            Ok(ImplicitBounds::new(",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": 277,
        "original_position": 236,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I know this `ImplicitBounds` naming is coming from PG, but why is it `implicit`?",
        "created_at": "2019-05-16T02:56:28Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284522779",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284522779"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284522779"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523197",
        "pull_request_review_id": 238158888,
        "id": 284523197,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDUyMzE5Nw==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": 254,
        "original_position": 216,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "hmm, now it is common sense that proof is a set of hash, but newbie will misunderstand that proof is NOT plural.",
        "created_at": "2019-05-16T02:59:23Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523197",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523197"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523197"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523220",
        "pull_request_review_id": 238158917,
        "id": 284523220,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDUyMzIyMA==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,\n+        root: &Bytes,\n+    ) -> Result<ImplicitBounds, Error> {\n+        let mut path: Vec<bool> = vec![];\n+        Self::get_path(idx, inclusion_proof.len(), path.as_mut());\n+        let first_left_end = path\n+            .iter()\n+            .position(|&p| p)\n+            .map(|pos| inclusion_proof[pos].clone())\n+            .map_or(0, |n| n.get_end());\n+        let mut computed = leaf.clone();\n+        for (i, item) in inclusion_proof.iter().enumerate() {\n+            if path[i] {\n+                computed = SumMerkleNode::compute_parent(item, &computed)\n+            } else {\n+                computed = SumMerkleNode::compute_parent(&computed, item)\n+            }\n+        }\n+        let is_last_leaf = 2u64.pow(inclusion_proof.len() as u32) - 1 == (idx as u64);\n+        if computed.hash() == root {\n+            Ok(ImplicitBounds::new(",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": 277,
        "original_position": 236,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "maybe they use `implicit bound` as `bound contained in the range of leaf`.",
        "created_at": "2019-05-16T02:59:30Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523220",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523220"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523220"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        },
        "in_reply_to_id": 284522779
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523615",
        "pull_request_review_id": 238159397,
        "id": 284523615,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDUyMzYxNQ==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,\n+        root: &Bytes,\n+    ) -> Result<ImplicitBounds, Error> {\n+        let mut path: Vec<bool> = vec![];\n+        Self::get_path(idx, inclusion_proof.len(), path.as_mut());\n+        let first_left_end = path\n+            .iter()\n+            .position(|&p| p)\n+            .map(|pos| inclusion_proof[pos].clone())\n+            .map_or(0, |n| n.get_end());\n+        let mut computed = leaf.clone();\n+        for (i, item) in inclusion_proof.iter().enumerate() {\n+            if path[i] {\n+                computed = SumMerkleNode::compute_parent(item, &computed)",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 229,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Multi args hash func cares about the order of args? Is that related to the [`ProofNode { data }`](https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17/files/d3369c5823a3ce4242143c343648755f5fabea47#r284329189) naming difficulty?",
        "created_at": "2019-05-16T03:02:18Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523615",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523615"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523615"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523832",
        "pull_request_review_id": 238159681,
        "id": 284523832,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDUyMzgzMg==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,\n+        root: &Bytes,\n+    ) -> Result<ImplicitBounds, Error> {\n+        let mut path: Vec<bool> = vec![];\n+        Self::get_path(idx, inclusion_proof.len(), path.as_mut());\n+        let first_left_end = path\n+            .iter()\n+            .position(|&p| p)\n+            .map(|pos| inclusion_proof[pos].clone())\n+            .map_or(0, |n| n.get_end());\n+        let mut computed = leaf.clone();\n+        for (i, item) in inclusion_proof.iter().enumerate() {\n+            if path[i] {",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": 267,
        "original_position": 228,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I can guess path is bool because this tree is binary tree. But couldn't guess which is right and which is left. Comment is preferable?",
        "created_at": "2019-05-16T03:03:49Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523832",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284523832"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284523832"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284583842",
        "pull_request_review_id": 238234575,
        "id": 284583842,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDU4Mzg0Mg==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,\n+        root: &Bytes,\n+    ) -> Result<ImplicitBounds, Error> {\n+        let mut path: Vec<bool> = vec![];\n+        Self::get_path(idx, inclusion_proof.len(), path.as_mut());\n+        let first_left_end = path\n+            .iter()\n+            .position(|&p| p)\n+            .map(|pos| inclusion_proof[pos].clone())\n+            .map_or(0, |n| n.get_end());\n+        let mut computed = leaf.clone();\n+        for (i, item) in inclusion_proof.iter().enumerate() {\n+            if path[i] {\n+                computed = SumMerkleNode::compute_parent(item, &computed)",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 229,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "hmm, is `SumMerkleNode::compute_parent` summing up the `item.sum` or something for determine range? I will check.",
        "created_at": "2019-05-16T08:05:29Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284583842",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284583842"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284583842"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        },
        "in_reply_to_id": 284523615
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284927019",
        "pull_request_review_id": 238674551,
        "id": 284927019,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDkyNzAxOQ==",
        "diff_hunk": "@@ -0,0 +1,369 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+/// SumMerkleNode is a node in merkle tree\n+///\n+///```text\n+///  full tree\n+///\n+///           root\n+///        /        \\\n+///      Node       Node\n+///     /   \\      /   \\\n+///   Leaf  Leaf Leaf  Leaf\n+///\n+///  branch and proof\n+///\n+///           root\n+///        /        \\\n+///      Node     ProofNode\n+///     /   \\      \n+///   Leaf  Leaf\n+///```\n+///\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    ProofNode {\n+        end: u64,\n+        data: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 68,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "fe893fe097452993171ed0eeaa55038a448a71e2",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "what wtr stands for?",
        "created_at": "2019-05-16T22:53:40Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284927019",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284927019"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284927019"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284933625",
        "pull_request_review_id": 238674551,
        "id": 284933625,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDkzMzYyNQ==",
        "diff_hunk": "@@ -0,0 +1,338 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    RightProofNode {\n+        end: u64,\n+        left: Bytes,\n+    },\n+\n+    LeftProofNode {\n+        end: u64,\n+        right: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();\n+    let mut buf = Bytes::new();\n+    buf.extend_from_slice(&wtr);\n+    buf.extend_from_slice(&data);\n+    hash_leaf(&buf)\n+}\n+\n+impl Hashable for SumMerkleNode {\n+    fn hash(&self) -> Bytes {\n+        match self {\n+            SumMerkleNode::Leaf { end, data } => compute_node(*end, data),\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let mut buf = compute_node(left.get_end(), &left.hash());\n+                buf.extend_from_slice(&compute_node(right.get_end(), &right.hash()));\n+                hash_leaf(&buf)\n+            }\n+            SumMerkleNode::RightProofNode { left, .. } => left.clone(),\n+            SumMerkleNode::LeftProofNode { right, .. } => right.clone(),\n+        }\n+    }\n+}\n+\n+impl SumMerkleNode {\n+    pub fn create_left_proof(right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::LeftProofNode {\n+            end: right.get_end(),\n+            right: right.hash(),\n+        }\n+    }\n+\n+    pub fn create_right_proof(left: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::RightProofNode {\n+            end: left.get_end(),\n+            left: left.hash(),\n+        }\n+    }\n+\n+    pub fn create_empty() -> Self {\n+        SumMerkleNode::Leaf {\n+            end: u64::max_value(),\n+            data: hash_leaf(&Bytes::from_static(&[0u8])),\n+        }\n+    }\n+\n+    pub fn create_leaf(end: u64, data: Bytes) -> Self {\n+        SumMerkleNode::Leaf { end, data }\n+    }\n+\n+    pub fn create_node(end: u64, left: &SumMerkleNode, right: &SumMerkleNode) -> Self {\n+        SumMerkleNode::Node {\n+            end,\n+            left: Box::new(left.clone()),\n+            right: Box::new(right.clone()),\n+        }\n+    }\n+\n+    pub fn compute_parent(left: &SumMerkleNode, right: &SumMerkleNode) -> SumMerkleNode {\n+        SumMerkleNode::create_node(right.get_end(), left, right)\n+    }\n+\n+    fn get_end(&self) -> u64 {\n+        match self {\n+            SumMerkleNode::Leaf { end, .. } => *end,\n+            SumMerkleNode::Node { end, .. } => *end,\n+            SumMerkleNode::RightProofNode { end, .. } => *end,\n+            SumMerkleNode::LeftProofNode { end, .. } => *end,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ImplicitBounds {\n+    implicit_start: u64,\n+    implicit_end: u64,\n+}\n+\n+impl ImplicitBounds {\n+    pub fn new(implicit_start: u64, implicit_end: u64) -> Self {\n+        ImplicitBounds {\n+            implicit_start,\n+            implicit_end,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SumMerkleTree {\n+    tree: SumMerkleNode,\n+}\n+\n+impl SumMerkleTree {\n+    /// generate sum merkle tree\n+    pub fn generate(leaves: &[SumMerkleNode]) -> SumMerkleTree {\n+        if leaves.len() <= 1 {\n+            return SumMerkleTree {\n+                tree: leaves[0].clone(),\n+            };\n+        }\n+        let mut parents = vec![];\n+        for chunk in leaves.chunks(2) {\n+            let v = chunk.to_vec();\n+            if chunk.len() == 1 {\n+                parents.push(SumMerkleNode::compute_parent(\n+                    &v[0],\n+                    &SumMerkleNode::create_empty(),\n+                ))\n+            } else {\n+                parents.push(SumMerkleNode::compute_parent(&v[0].clone(), &v[1].clone()))\n+            }\n+        }\n+        SumMerkleTree::generate(&parents)\n+    }\n+\n+    /// Calculate merkle root\n+    pub fn get_root(&self) -> Bytes {\n+        self.tree.hash()\n+    }\n+\n+    /// Returns inclusion proof for a leaf\n+    pub fn get_inclusion_proof(&self, idx: usize, count: usize) -> Vec<SumMerkleNode> {\n+        SumMerkleTree::get_inclusion_proof_of_tree(&self.tree, idx, count)\n+    }\n+\n+    fn get_inclusion_proof_of_tree(\n+        tree: &SumMerkleNode,\n+        idx: usize,\n+        count: usize,\n+    ) -> Vec<SumMerkleNode> {\n+        match tree {\n+            SumMerkleNode::Leaf { .. } => vec![],\n+            SumMerkleNode::Node { left, right, .. } => {\n+                let left_count = count.next_power_of_two() / 2;\n+                if idx < left_count {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(left, idx, left_count);\n+                    proofs.push(SumMerkleNode::create_left_proof(&right));\n+                    proofs\n+                } else {\n+                    let mut proofs = Self::get_inclusion_proof_of_tree(\n+                        right,\n+                        idx - left_count,\n+                        count - left_count,\n+                    );\n+                    proofs.push(SumMerkleNode::create_right_proof(&left));\n+                    proofs\n+                }\n+            }\n+            SumMerkleNode::LeftProofNode { .. } => vec![],\n+            SumMerkleNode::RightProofNode { .. } => vec![],\n+        }\n+    }\n+\n+    fn get_path(idx: usize, depth: usize, path: &mut Vec<bool>) {\n+        if depth == 0 {\n+            return;\n+        }\n+        path.push((idx & 0x01) != 0);\n+        Self::get_path(idx.rotate_right(1), depth - 1, path)\n+    }\n+\n+    /// Verify whether leaf is included or not\n+    pub fn verify(\n+        leaf: &SumMerkleNode,\n+        idx: usize,\n+        inclusion_proof: Vec<SumMerkleNode>,\n+        root: &Bytes,\n+    ) -> Result<ImplicitBounds, Error> {\n+        let mut path: Vec<bool> = vec![];\n+        Self::get_path(idx, inclusion_proof.len(), path.as_mut());\n+        let first_left_end = path\n+            .iter()\n+            .position(|&p| p)\n+            .map(|pos| inclusion_proof[pos].clone())\n+            .map_or(0, |n| n.get_end());\n+        let mut computed = leaf.clone();\n+        for (i, item) in inclusion_proof.iter().enumerate() {\n+            if path[i] {\n+                computed = SumMerkleNode::compute_parent(item, &computed)",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 229,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "d3369c5823a3ce4242143c343648755f5fabea47",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "~Trivial nit-picking though, I couldn't intuitively guess the compute_parent func is a hash func, hence I'm less careful about the order of args.~\r\n\r\n~The func name had better to be hash func ish.~\r\n\r\nAh it's okay because the func isn't a simple hash func, it is generating new node from children. ",
        "created_at": "2019-05-16T23:26:52Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284933625",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284933625"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284933625"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        },
        "in_reply_to_id": 284523615
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284941419",
        "pull_request_review_id": 238692234,
        "id": 284941419,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDk0MTQxOQ==",
        "diff_hunk": "@@ -0,0 +1,369 @@\n+extern crate crypto;\n+\n+use self::crypto::sha3::Sha3;\n+use byteorder::{LittleEndian, WriteBytesExt};\n+use bytes::Bytes;\n+use crypto::digest::Digest;\n+\n+#[derive(Debug)]\n+pub enum Error {\n+    VerifyError,\n+}\n+\n+fn hash_leaf(value: &Bytes) -> Bytes {\n+    let mut hasher = Sha3::keccak256();\n+    let mut result = vec![0u8; hasher.output_bits() / 8];\n+    hasher.reset();\n+    hasher.input(value.as_ref());\n+    hasher.result(result.as_mut_slice());\n+    Bytes::from(result)\n+}\n+\n+trait Hashable {\n+    fn hash(&self) -> Bytes;\n+}\n+\n+/// SumMerkleNode is a node in merkle tree\n+///\n+///```text\n+///  full tree\n+///\n+///           root\n+///        /        \\\n+///      Node       Node\n+///     /   \\      /   \\\n+///   Leaf  Leaf Leaf  Leaf\n+///\n+///  branch and proof\n+///\n+///           root\n+///        /        \\\n+///      Node     ProofNode\n+///     /   \\      \n+///   Leaf  Leaf\n+///```\n+///\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum SumMerkleNode {\n+    Leaf {\n+        end: u64,\n+        data: Bytes,\n+    },\n+\n+    Node {\n+        end: u64,\n+        left: Box<SumMerkleNode>,\n+        right: Box<SumMerkleNode>,\n+    },\n+\n+    ProofNode {\n+        end: u64,\n+        data: Bytes,\n+    },\n+}\n+\n+/// Caluculate hash of a node\n+fn compute_node(end: u64, data: &Bytes) -> Bytes {\n+    let mut wtr = vec![];\n+    wtr.write_u64::<LittleEndian>(end).unwrap();",
        "path": "sum_merkle_tree/src/lib.rs",
        "position": null,
        "original_position": 68,
        "commit_id": "f4ed4be6054f632c83e0966c1428e5d622c92370",
        "original_commit_id": "fe893fe097452993171ed0eeaa55038a448a71e2",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "wtr is`writer` and it is byte buffer for `end`. changed name.",
        "created_at": "2019-05-17T00:13:00Z",
        "updated_at": "2019-05-17T00:14:50Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284941419",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284941419"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/17#discussion_r284941419"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/17"
            }
        },
        "in_reply_to_id": 284927019
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284151159",
        "pull_request_review_id": 237688305,
        "id": 284151159,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDE1MTE1OQ==",
        "diff_hunk": "@@ -0,0 +1,35 @@\n+//\n+// Created on Wed May 15 2019\n+//\n+// Copyright (c) 2019 Cryptoeconomics Lab, Inc.\n+// This file is part of Plasma Chamber.\n+//\n+\n+extern crate plasma_core;\n+\n+use super::error::Error;\n+use parking_lot::RwLock;\n+use plasma_core::data_structure::{Block, SignedTransaction};\n+use plasma_core::process::BlockGenerator;\n+use std::sync::Arc;\n+\n+#[derive(Default)]\n+pub struct ChainContext {\n+    signed_transactions: Arc<RwLock<Vec<SignedTransaction>>>,",
        "path": "operator/src/context.rs",
        "position": null,
        "original_position": 18,
        "commit_id": "e7458a235fbaffa188bb6f6769696f743a0362a7",
        "original_commit_id": "c62028ce058aeb44f7a64581d9e124debab9608a",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "this is transaction queue. I will add comment and change name.",
        "created_at": "2019-05-15T08:54:05Z",
        "updated_at": "2019-05-20T01:02:01Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/20#discussion_r284151159",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/20",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284151159"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/20#discussion_r284151159"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/20"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284945692",
        "pull_request_review_id": 238697431,
        "id": 284945692,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NDk0NTY5Mg==",
        "diff_hunk": "@@ -6,30 +6,63 @@\n //\n \n extern crate jsonrpc_core;\n+extern crate plasma_core;\n+extern crate rlp;\n \n use super::plasmarpc::PlasmaRpc;\n-use jsonrpc_core::Result;\n+use crate::context::ChainContext;\n+use jsonrpc_core::{Error as JsonRpcError, ErrorCode, Result};\n+use plasma_core::data_structure::Transaction;\n \n /// Plasma JSON RPC implementation.\n-pub struct PlasmaRpcImpl;\n+#[derive(Default)]\n+pub struct PlasmaRpcImpl {\n+    chain_context: ChainContext,\n+}\n+\n+impl PlasmaRpcImpl {\n+    pub fn new() -> PlasmaRpcImpl {\n+        PlasmaRpcImpl {\n+            chain_context: Default::default(),\n+        }\n+    }\n+}\n \n impl PlasmaRpc for PlasmaRpcImpl {\n     fn protocol_version(&self) -> Result<String> {\n         Ok(\"0.1.0\".into())\n     }\n+    fn send_transaction(&self, message: String) -> Result<bool> {\n+        let rlp_bytes =\n+            hex::decode(message).map_err(|_err| JsonRpcError::new(ErrorCode::ParseError))?;\n+        let transaction: Transaction =\n+            rlp::decode(&rlp_bytes).map_err(|_err| JsonRpcError::new(ErrorCode::ParseError))?;",
        "path": "operator/src/rpc/plasmarpcimpl.rs",
        "position": null,
        "original_position": 36,
        "commit_id": "e7458a235fbaffa188bb6f6769696f743a0362a7",
        "original_commit_id": "800753db9d60c26e3474b6093c46177729328eb1",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@tkmct Do you have any ideas to clean up these codes? I wanna receive RLP string and parse to Transaction. When decode error occurerd, it returns`JsonRpcError`.",
        "created_at": "2019-05-17T00:42:03Z",
        "updated_at": "2019-05-20T01:02:01Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/20#discussion_r284945692",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/20",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/284945692"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/20#discussion_r284945692"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/20"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/285406114",
        "pull_request_review_id": 239264910,
        "id": 285406114,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4NTQwNjExNA==",
        "diff_hunk": "@@ -6,30 +6,63 @@\n //\n \n extern crate jsonrpc_core;\n+extern crate plasma_core;\n+extern crate rlp;\n \n use super::plasmarpc::PlasmaRpc;\n-use jsonrpc_core::Result;\n+use crate::context::ChainContext;\n+use jsonrpc_core::{Error as JsonRpcError, ErrorCode, Result};\n+use plasma_core::data_structure::Transaction;\n \n /// Plasma JSON RPC implementation.\n-pub struct PlasmaRpcImpl;\n+#[derive(Default)]\n+pub struct PlasmaRpcImpl {\n+    chain_context: ChainContext,\n+}\n+\n+impl PlasmaRpcImpl {\n+    pub fn new() -> PlasmaRpcImpl {\n+        PlasmaRpcImpl {\n+            chain_context: Default::default(),\n+        }\n+    }\n+}\n \n impl PlasmaRpc for PlasmaRpcImpl {\n     fn protocol_version(&self) -> Result<String> {\n         Ok(\"0.1.0\".into())\n     }\n+    fn send_transaction(&self, message: String) -> Result<bool> {\n+        let rlp_bytes =\n+            hex::decode(message).map_err(|_err| JsonRpcError::new(ErrorCode::ParseError))?;\n+        let transaction: Transaction =\n+            rlp::decode(&rlp_bytes).map_err(|_err| JsonRpcError::new(ErrorCode::ParseError))?;",
        "path": "operator/src/rpc/plasmarpcimpl.rs",
        "position": null,
        "original_position": 36,
        "commit_id": "e7458a235fbaffa188bb6f6769696f743a0362a7",
        "original_commit_id": "800753db9d60c26e3474b6093c46177729328eb1",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I added error definitions of json-rpc. and cleaned code!",
        "created_at": "2019-05-20T00:47:48Z",
        "updated_at": "2019-05-20T01:02:01Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/20#discussion_r285406114",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/20",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/285406114"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/20#discussion_r285406114"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/20"
            }
        },
        "in_reply_to_id": 284945692
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289213680",
        "pull_request_review_id": 244081094,
        "id": 289213680,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTIxMzY4MA==",
        "diff_hunk": "@@ -0,0 +1,46 @@\n+use crate::error::{Error, ErrorKind};\n+use crate::traits::db::DatabaseTrait;\n+use crate::traits::kvs::{Batch, KeyValueStore, KvsIterator};\n+use kvdb::{DBTransaction, KeyValueDB};\n+use kvdb_memorydb::InMemory;\n+\n+pub struct CoreDb {\n+    db: InMemory,\n+}\n+\n+impl DatabaseTrait for CoreDb {\n+    fn open(_dbname: &str) -> Self {\n+        CoreDb {\n+            db: Default::default(),\n+        }\n+    }\n+    fn close(&self) {}\n+}\n+\n+impl KeyValueStore for CoreDb {",
        "path": "db/src/impls/kvs/kvdb.rs",
        "position": 20,
        "original_position": 20,
        "commit_id": "83a9da4f3c86764be2e1eeb86c6ba1dd24ae043a",
        "original_commit_id": "4f3c2e621bbd2fdddbf9ef459f04448ae80dcf10",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Ah, this is good. trait can be impl-ed multiple times. ",
        "created_at": "2019-05-30T23:47:03Z",
        "updated_at": "2019-05-31T03:10:03Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289213680",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289213680"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289213680"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289214260",
        "pull_request_review_id": 244081094,
        "id": 289214260,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTIxNDI2MA==",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+use crate::error::Error;\n+\n+pub enum Batch<'a> {\n+    BatchPut { key: &'a [u8], value: &'a [u8] },\n+    BatchDel { key: &'a [u8] },\n+}\n+\n+pub struct KeyValue {\n+    key: Box<[u8]>,\n+    value: Box<[u8]>,\n+}\n+\n+impl KeyValue {\n+    pub fn get_key(&self) -> &[u8] {\n+        &self.key\n+    }\n+    pub fn get_value(&self) -> &[u8] {\n+        &self.value\n+    }\n+}\n+\n+pub trait KvsIterator {\n+    fn next(&self) -> Result<KeyValue, Error>;\n+}\n+\n+pub trait KeyValueStore {\n+    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, Error>;",
        "path": "db/src/traits/kvs.rs",
        "position": null,
        "original_position": 27,
        "commit_id": "83a9da4f3c86764be2e1eeb86c6ba1dd24ae043a",
        "original_commit_id": "4f3c2e621bbd2fdddbf9ef459f04448ae80dcf10",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "using `[]` for args and `Vec` for return.\r\n\r\nAny reasoning on it?",
        "created_at": "2019-05-30T23:50:11Z",
        "updated_at": "2019-05-31T03:10:03Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289214260",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289214260"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289214260"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289215546",
        "pull_request_review_id": 244081094,
        "id": 289215546,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTIxNTU0Ng==",
        "diff_hunk": "@@ -0,0 +1,79 @@\n+use rlp::{Decodable, DecoderError, Encodable, Rlp, RlpStream};\n+use std::cmp::{max, min, Ordering};\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct Range {\n+    start: u64,\n+    end: u64,\n+    value: Vec<u8>,\n+}\n+\n+impl Ord for Range {\n+    fn cmp(&self, other: &Range) -> Ordering {\n+        self.end.cmp(&other.end)\n+    }\n+}\n+\n+impl PartialOrd for Range {\n+    fn partial_cmp(&self, other: &Range) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Range {\n+    pub fn new(start: u64, end: u64, value: &[u8]) -> Self {\n+        Range {\n+            start,\n+            end,\n+            value: value.to_vec(),\n+        }\n+    }\n+    pub fn get_start(&self) -> u64 {\n+        self.start\n+    }\n+    pub fn get_end(&self) -> u64 {\n+        self.end\n+    }\n+    pub fn get_value(&self) -> &[u8] {\n+        &self.value\n+    }\n+    pub fn validate(&self) -> bool {\n+        self.start < self.end\n+    }\n+    pub fn intersect(&self, start: u64, end: u64) -> bool {",
        "path": "db/src/range.rs",
        "position": 43,
        "original_position": 43,
        "commit_id": "83a9da4f3c86764be2e1eeb86c6ba1dd24ae043a",
        "original_commit_id": "057dd31fb926bd7888b7f59afdf549c1b9359ab3",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "How would this func be used?",
        "created_at": "2019-05-30T23:57:12Z",
        "updated_at": "2019-05-31T03:10:03Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289215546",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289215546"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289215546"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289216504",
        "pull_request_review_id": 244084460,
        "id": 289216504,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTIxNjUwNA==",
        "diff_hunk": "@@ -0,0 +1,79 @@\n+use rlp::{Decodable, DecoderError, Encodable, Rlp, RlpStream};\n+use std::cmp::{max, min, Ordering};\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct Range {\n+    start: u64,\n+    end: u64,\n+    value: Vec<u8>,\n+}\n+\n+impl Ord for Range {\n+    fn cmp(&self, other: &Range) -> Ordering {\n+        self.end.cmp(&other.end)\n+    }\n+}\n+\n+impl PartialOrd for Range {\n+    fn partial_cmp(&self, other: &Range) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Range {\n+    pub fn new(start: u64, end: u64, value: &[u8]) -> Self {\n+        Range {\n+            start,\n+            end,\n+            value: value.to_vec(),\n+        }\n+    }\n+    pub fn get_start(&self) -> u64 {\n+        self.start\n+    }\n+    pub fn get_end(&self) -> u64 {\n+        self.end\n+    }\n+    pub fn get_value(&self) -> &[u8] {\n+        &self.value\n+    }\n+    pub fn validate(&self) -> bool {\n+        self.start < self.end\n+    }\n+    pub fn intersect(&self, start: u64, end: u64) -> bool {",
        "path": "db/src/range.rs",
        "position": 43,
        "original_position": 43,
        "commit_id": "83a9da4f3c86764be2e1eeb86c6ba1dd24ae043a",
        "original_commit_id": "057dd31fb926bd7888b7f59afdf549c1b9359ab3",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This is from https://github.com/plasma-group/pigi/blob/master/packages/operator/src/app/db/range-db.ts#L124.\r\nThis function checks the range intersect another range.\r\n",
        "created_at": "2019-05-31T00:02:41Z",
        "updated_at": "2019-05-31T03:10:03Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289216504",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289216504"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289216504"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42"
            }
        },
        "in_reply_to_id": 289215546
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289219089",
        "pull_request_review_id": 244087566,
        "id": 289219089,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTIxOTA4OQ==",
        "diff_hunk": "@@ -0,0 +1,33 @@\n+use crate::error::Error;\n+\n+pub enum Batch<'a> {\n+    BatchPut { key: &'a [u8], value: &'a [u8] },\n+    BatchDel { key: &'a [u8] },\n+}\n+\n+pub struct KeyValue {\n+    key: Box<[u8]>,\n+    value: Box<[u8]>,\n+}\n+\n+impl KeyValue {\n+    pub fn get_key(&self) -> &[u8] {\n+        &self.key\n+    }\n+    pub fn get_value(&self) -> &[u8] {\n+        &self.value\n+    }\n+}\n+\n+pub trait KvsIterator {\n+    fn next(&self) -> Result<KeyValue, Error>;\n+}\n+\n+pub trait KeyValueStore {\n+    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, Error>;",
        "path": "db/src/traits/kvs.rs",
        "position": null,
        "original_position": 27,
        "commit_id": "83a9da4f3c86764be2e1eeb86c6ba1dd24ae043a",
        "original_commit_id": "4f3c2e621bbd2fdddbf9ef459f04448ae80dcf10",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Good question.\r\nbasically, I think we should use &[T] instead of Vec as arguments when we don't modify array.\r\n\r\nAnd in Option\\<T\\>, T should be Sized type. So T is wrapped by Vec or Box. in this case Box would be better.\r\nI modified return type.\r\n",
        "created_at": "2019-05-31T00:18:00Z",
        "updated_at": "2019-05-31T03:10:03Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289219089",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289219089"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289219089"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42"
            }
        },
        "in_reply_to_id": 289214260
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289219759",
        "pull_request_review_id": 244088370,
        "id": 289219759,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTIxOTc1OQ==",
        "diff_hunk": "@@ -0,0 +1,159 @@\n+extern crate leveldb;\n+extern crate tempdir;\n+\n+use crate::error::{Error, ErrorKind};\n+use crate::range::Range;\n+use crate::traits::db::DatabaseTrait;\n+use crate::traits::rangestore::RangeStore;\n+//use db_key::Key;\n+use leveldb::database::{batch::Writebatch, Database};\n+use leveldb::iterator::Iterable;\n+//use leveldb::kv::KV;\n+use leveldb::batch::Batch;\n+use leveldb::iterator::LevelDBIterator;\n+use leveldb::options::{Options, ReadOptions, WriteOptions};\n+use tempdir::TempDir;\n+\n+pub struct RangeDbLevelImpl {\n+    db: Database<i32>,",
        "path": "db/src/impls/rangestore/leveldb.rs",
        "position": 18,
        "original_position": 18,
        "commit_id": "83a9da4f3c86764be2e1eeb86c6ba1dd24ae043a",
        "original_commit_id": "ed089ea354382920a2a945eea64016a6531f2102",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This should be `Database<u64>`, I make `db_key:Key` for u64 in the next PR.\r\n",
        "created_at": "2019-05-31T00:22:09Z",
        "updated_at": "2019-05-31T03:10:03Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289219759",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289219759"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/42#discussion_r289219759"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/42"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289692876",
        "pull_request_review_id": 244686300,
        "id": 289692876,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTY5Mjg3Ng==",
        "diff_hunk": "@@ -0,0 +1,125 @@\n+use crate::data_structure::error::Error;\n+use crate::data_structure::state_update::StateUpdate;\n+use crate::data_structure::transaction::Transaction;\n+use plasma_db::impls::rangestore::memory::RangeDbMemoryImpl;\n+use plasma_db::range::Range;\n+use plasma_db::traits::db::DatabaseTrait;\n+use plasma_db::traits::rangestore::RangeStore;\n+\n+struct MockPredicatePlugin {}\n+impl MockPredicatePlugin {",
        "path": "core/src/state_manager.rs",
        "position": null,
        "original_position": 10,
        "commit_id": "6df32025760dc133750a0f9ce0ebf9184d96dac7",
        "original_commit_id": "0fbf0696cbfab0ddeba5887a2291083ae6d3cb0d",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Now using mock \"Predicate Plugin\".",
        "created_at": "2019-06-03T05:38:31Z",
        "updated_at": "2019-06-03T07:11:30Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/43#discussion_r289692876",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/43",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289692876"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/43#discussion_r289692876"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/43"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289711972",
        "pull_request_review_id": 244710383,
        "id": 289711972,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTcxMTk3Mg==",
        "diff_hunk": "@@ -0,0 +1,165 @@\n+use crate::data_structure::error::Error;\n+use crate::data_structure::{StateUpdate, Transaction};\n+use crate::state::{StateDb, VerifiedStateUpdate};\n+\n+struct MockPredicatePlugin {}\n+impl MockPredicatePlugin {\n+    pub fn execute_state_transition(\n+        input: &StateUpdate,\n+        _transaction: &Transaction,\n+    ) -> StateUpdate {\n+        input.clone()\n+    }\n+}\n+\n+pub struct ResultOfExecuteTransaction {\n+    state_update: Box<StateUpdate>,\n+    ranges: Box<[VerifiedStateUpdate]>,\n+}\n+\n+impl ResultOfExecuteTransaction {\n+    pub fn new(state_update: &StateUpdate, ranges: &[VerifiedStateUpdate]) -> Self {\n+        ResultOfExecuteTransaction {\n+            state_update: Box::new(state_update.clone()),\n+            ranges: ranges.to_vec().into_boxed_slice(),\n+        }\n+    }\n+    pub fn get_state_update(&self) -> &StateUpdate {\n+        &self.state_update\n+    }\n+    pub fn get_ranges(&self) -> &[VerifiedStateUpdate] {\n+        &self.ranges\n+    }\n+}\n+\n+pub struct StateManager {\n+    db: Box<StateDb>,\n+}\n+\n+impl Default for StateManager {\n+    fn default() -> Self {\n+        Self {\n+            db: Default::default(),\n+        }\n+    }\n+}\n+\n+impl StateManager {\n+    /// force to put state update\n+    pub fn deposit(&self, start: u64, end: u64, state_update: &StateUpdate) -> Result<(), Error> {\n+        self.db\n+            .put_verified_state_update(&VerifiedStateUpdate::new(start, end, 0, state_update))\n+    }\n+\n+    /// Execute a transaction\n+    pub fn execute_transaction(\n+        &self,\n+        transaction: &Transaction,\n+    ) -> Result<ResultOfExecuteTransaction, Error> {\n+        let verified_state_updates = self\n+            .db\n+            .get_verified_state_updates(transaction.get_start(), transaction.get_end())?;\n+        let new_state_updates: Vec<StateUpdate> = verified_state_updates\n+            .iter()\n+            .map(|verified_state_update| {\n+                MockPredicatePlugin::execute_state_transition(\n+                    verified_state_update.get_state_update(),\n+                    transaction,\n+                )\n+            })\n+            .collect();\n+        // new_state_updates should has same state_update\n+        let new_state_update: &StateUpdate = &new_state_updates[0];",
        "path": "core/src/state/state_manager.rs",
        "position": 72,
        "original_position": 72,
        "commit_id": "6df32025760dc133750a0f9ce0ebf9184d96dac7",
        "original_commit_id": "6df32025760dc133750a0f9ce0ebf9184d96dac7",
        "user": {
            "login": "syuhei176",
            "id": 1094660,
            "node_id": "MDQ6VXNlcjEwOTQ2NjA=",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1094660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/syuhei176",
            "html_url": "https://github.com/syuhei176",
            "followers_url": "https://api.github.com/users/syuhei176/followers",
            "following_url": "https://api.github.com/users/syuhei176/following{/other_user}",
            "gists_url": "https://api.github.com/users/syuhei176/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/syuhei176/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/syuhei176/subscriptions",
            "organizations_url": "https://api.github.com/users/syuhei176/orgs",
            "repos_url": "https://api.github.com/users/syuhei176/repos",
            "events_url": "https://api.github.com/users/syuhei176/events{/privacy}",
            "received_events_url": "https://api.github.com/users/syuhei176/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I'm not sure how to merge multiple `stateUpdates`. It's enough to check all outputs are the same `stateUpdate`?\r\n",
        "created_at": "2019-06-03T07:14:12Z",
        "updated_at": "2019-06-03T07:14:13Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/43#discussion_r289711972",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/43",
        "author_association": "MEMBER",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289711972"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/43#discussion_r289711972"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/43"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289713586",
        "pull_request_review_id": 244712343,
        "id": 289713586,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI4OTcxMzU4Ng==",
        "diff_hunk": "@@ -0,0 +1,165 @@\n+use crate::data_structure::error::Error;\n+use crate::data_structure::{StateUpdate, Transaction};\n+use crate::state::{StateDb, VerifiedStateUpdate};\n+\n+struct MockPredicatePlugin {}\n+impl MockPredicatePlugin {\n+    pub fn execute_state_transition(\n+        input: &StateUpdate,\n+        _transaction: &Transaction,\n+    ) -> StateUpdate {\n+        input.clone()\n+    }\n+}\n+\n+pub struct ResultOfExecuteTransaction {\n+    state_update: Box<StateUpdate>,\n+    ranges: Box<[VerifiedStateUpdate]>,\n+}\n+\n+impl ResultOfExecuteTransaction {\n+    pub fn new(state_update: &StateUpdate, ranges: &[VerifiedStateUpdate]) -> Self {\n+        ResultOfExecuteTransaction {\n+            state_update: Box::new(state_update.clone()),\n+            ranges: ranges.to_vec().into_boxed_slice(),\n+        }\n+    }\n+    pub fn get_state_update(&self) -> &StateUpdate {\n+        &self.state_update\n+    }\n+    pub fn get_ranges(&self) -> &[VerifiedStateUpdate] {\n+        &self.ranges\n+    }\n+}\n+\n+pub struct StateManager {\n+    db: Box<StateDb>,\n+}\n+\n+impl Default for StateManager {\n+    fn default() -> Self {\n+        Self {\n+            db: Default::default(),\n+        }\n+    }\n+}\n+\n+impl StateManager {\n+    /// force to put state update\n+    pub fn deposit(&self, start: u64, end: u64, state_update: &StateUpdate) -> Result<(), Error> {\n+        self.db\n+            .put_verified_state_update(&VerifiedStateUpdate::new(start, end, 0, state_update))\n+    }\n+\n+    /// Execute a transaction\n+    pub fn execute_transaction(\n+        &self,\n+        transaction: &Transaction,\n+    ) -> Result<ResultOfExecuteTransaction, Error> {\n+        let verified_state_updates = self\n+            .db\n+            .get_verified_state_updates(transaction.get_start(), transaction.get_end())?;\n+        let new_state_updates: Vec<StateUpdate> = verified_state_updates\n+            .iter()\n+            .map(|verified_state_update| {\n+                MockPredicatePlugin::execute_state_transition(\n+                    verified_state_update.get_state_update(),\n+                    transaction,\n+                )\n+            })\n+            .collect();\n+        // new_state_updates should has same state_update\n+        let new_state_update: &StateUpdate = &new_state_updates[0];\n+        self.db\n+            .put_verified_state_update(&VerifiedStateUpdate::from(\n+                new_state_update.get_block_number(),\n+                new_state_update,\n+            ))?;\n+        Ok(ResultOfExecuteTransaction::new(\n+            new_state_update,\n+            &verified_state_updates,\n+        ))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::StateManager;\n+    use crate::data_structure::{StateObject, StateUpdate, Transaction, Witness};\n+    use ethereum_types::{Address, H256};\n+\n+    fn create_state_update(start: u64, end: u64, block_number: u64) -> StateUpdate {\n+        StateUpdate::new(\n+            &StateObject::new(Address::zero(), &b\"data\"[..]),\n+            start,\n+            end,\n+            block_number,\n+            Address::zero(),\n+        )\n+    }\n+\n+    #[test]\n+    fn test_execute_transaction() {\n+        // make state update\n+        let state_update = create_state_update(0, 100, 1);\n+        // make transaction\n+        let transaction = Transaction::new(\n+            Address::zero(),\n+            0,\n+            100,\n+            Transaction::create_method_id(&b\"send(address)\"[..]),\n+            &b\"new state update\"[..],\n+            &Witness::new(H256::zero(), H256::zero(), 0),\n+        );\n+\n+        let state_manager: StateManager = Default::default();",
        "path": "core/src/state/state_manager.rs",
        "position": 115,
        "original_position": 115,
        "commit_id": "6df32025760dc133750a0f9ce0ebf9184d96dac7",
        "original_commit_id": "6df32025760dc133750a0f9ce0ebf9184d96dac7",
        "user": {
            "login": "shogochiai",
            "id": 4891004,
            "node_id": "MDQ6VXNlcjQ4OTEwMDQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4891004?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shogochiai",
            "html_url": "https://github.com/shogochiai",
            "followers_url": "https://api.github.com/users/shogochiai/followers",
            "following_url": "https://api.github.com/users/shogochiai/following{/other_user}",
            "gists_url": "https://api.github.com/users/shogochiai/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/shogochiai/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/shogochiai/subscriptions",
            "organizations_url": "https://api.github.com/users/shogochiai/orgs",
            "repos_url": "https://api.github.com/users/shogochiai/repos",
            "events_url": "https://api.github.com/users/shogochiai/events{/privacy}",
            "received_events_url": "https://api.github.com/users/shogochiai/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Why is this very abstract trait is generating a concrete state manager?",
        "created_at": "2019-06-03T07:19:42Z",
        "updated_at": "2019-06-03T07:19:43Z",
        "html_url": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/43#discussion_r289713586",
        "pull_request_url": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/43",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/comments/289713586"
            },
            "html": {
                "href": "https://github.com/cryptoeconomicslab/plasma-rust-framework/pull/43#discussion_r289713586"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/cryptoeconomicslab/plasma-rust-framework/pulls/43"
            }
        }
    }
]