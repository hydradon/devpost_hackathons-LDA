[
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479253",
        "pull_request_review_id": null,
        "id": 13479253,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNDc5MjUz",
        "diff_hunk": "@@ -452,6 +481,8 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// directory at the provided path, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()))\n+        .update_err(\"couldn't remove directory\",\n+            |e| format!(\"{}; path={}\", e, path.display()))",
        "path": "src/libstd/io/fs.rs",
        "position": null,
        "original_position": 210,
        "commit_id": "5ae6e93a0ef345a26426f60eecaf1448446d72eb",
        "original_commit_id": "72f3b20660f7e7f1113dd27258f80f23dd82dd1e",
        "user": {
            "login": "wycats",
            "id": 4,
            "node_id": "MDQ6VXNlcjQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wycats",
            "html_url": "https://github.com/wycats",
            "followers_url": "https://api.github.com/users/wycats/followers",
            "following_url": "https://api.github.com/users/wycats/following{/other_user}",
            "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wycats/subscriptions",
            "organizations_url": "https://api.github.com/users/wycats/orgs",
            "repos_url": "https://api.github.com/users/wycats/repos",
            "events_url": "https://api.github.com/users/wycats/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wycats/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I feel like there is a conspiracy to make each method call at least 10 lines ;)\n",
        "created_at": "2014-06-06T07:42:17Z",
        "updated_at": "2014-06-06T22:48:56Z",
        "html_url": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479253",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/14629",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479253"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479253"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/14629"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479266",
        "pull_request_review_id": null,
        "id": 13479266,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNDc5MjY2",
        "diff_hunk": "@@ -719,6 +805,13 @@ mod test {\n         }\n     ) )\n \n+    macro_rules! error( ($e:expr, $s:expr) => (\n+        match $e {\n+            Ok(val) => fail!(\"Should have been an error, was {:?}\", val),\n+            Err(ref err) => assert!(err.to_str().as_slice().contains($s.as_slice()), format!(\"`{}` did not contain `{}`\", err, $s))",
        "path": "src/libstd/io/fs.rs",
        "position": null,
        "original_position": 406,
        "commit_id": "5ae6e93a0ef345a26426f60eecaf1448446d72eb",
        "original_commit_id": "72f3b20660f7e7f1113dd27258f80f23dd82dd1e",
        "user": {
            "login": "wycats",
            "id": 4,
            "node_id": "MDQ6VXNlcjQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wycats",
            "html_url": "https://github.com/wycats",
            "followers_url": "https://api.github.com/users/wycats/followers",
            "following_url": "https://api.github.com/users/wycats/following{/other_user}",
            "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wycats/subscriptions",
            "organizations_url": "https://api.github.com/users/wycats/orgs",
            "repos_url": "https://api.github.com/users/wycats/repos",
            "events_url": "https://api.github.com/users/wycats/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wycats/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It looked like tests had a different limit?\n",
        "created_at": "2014-06-06T07:42:40Z",
        "updated_at": "2014-06-06T22:48:56Z",
        "html_url": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479266",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/14629",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479266"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479266"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/14629"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479277",
        "pull_request_review_id": null,
        "id": 13479277,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNDc5Mjc3",
        "diff_hunk": "@@ -303,6 +303,8 @@ impl IoError {\n     /// struct is filled with an allocated string describing the error\n     /// in more detail, retrieved from the operating system.\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n+        use str::Str;",
        "path": "src/libstd/io/mod.rs",
        "position": null,
        "original_position": 4,
        "commit_id": "5ae6e93a0ef345a26426f60eecaf1448446d72eb",
        "original_commit_id": "72f3b20660f7e7f1113dd27258f80f23dd82dd1e",
        "user": {
            "login": "wycats",
            "id": 4,
            "node_id": "MDQ6VXNlcjQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wycats",
            "html_url": "https://github.com/wycats",
            "followers_url": "https://api.github.com/users/wycats/followers",
            "following_url": "https://api.github.com/users/wycats/following{/other_user}",
            "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wycats/subscriptions",
            "organizations_url": "https://api.github.com/users/wycats/orgs",
            "repos_url": "https://api.github.com/users/wycats/repos",
            "events_url": "https://api.github.com/users/wycats/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wycats/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Sure.\n",
        "created_at": "2014-06-06T07:43:01Z",
        "updated_at": "2014-06-06T22:48:56Z",
        "html_url": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479277",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/14629",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479277"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479277"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/14629"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479307",
        "pull_request_review_id": null,
        "id": 13479307,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNDc5MzA3",
        "diff_hunk": "@@ -365,8 +367,8 @@ impl IoError {\n         IoError {\n             kind: kind,\n             desc: desc,\n-            detail: if detail {\n-                Some(os::error_string(errno))\n+            detail: if detail && kind == OtherIoError {\n+                Some(os::error_string(errno).as_slice().chars().map(|c| c.to_lowercase()).collect())",
        "path": "src/libstd/io/mod.rs",
        "position": 24,
        "original_position": 16,
        "commit_id": "5ae6e93a0ef345a26426f60eecaf1448446d72eb",
        "original_commit_id": "72f3b20660f7e7f1113dd27258f80f23dd82dd1e",
        "user": {
            "login": "wycats",
            "id": 4,
            "node_id": "MDQ6VXNlcjQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wycats",
            "html_url": "https://github.com/wycats",
            "followers_url": "https://api.github.com/users/wycats/followers",
            "following_url": "https://api.github.com/users/wycats/following{/other_user}",
            "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wycats/subscriptions",
            "organizations_url": "https://api.github.com/users/wycats/orgs",
            "repos_url": "https://api.github.com/users/wycats/repos",
            "events_url": "https://api.github.com/users/wycats/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wycats/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Yeah. I think we should try to have consistency between error messages that are produced in userland (like in libuv, for example) and ones that are produced by the OS.\n",
        "created_at": "2014-06-06T07:44:03Z",
        "updated_at": "2014-06-06T22:48:56Z",
        "html_url": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479307",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/14629",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479307"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479307"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/14629"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479328",
        "pull_request_review_id": null,
        "id": 13479328,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNDc5MzI4",
        "diff_hunk": "@@ -386,10 +388,13 @@ impl IoError {\n \n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{}\", self.desc));\n-        match self.detail {\n-            Some(ref s) => write!(fmt, \" ({})\", *s),\n-            None => Ok(())\n+        match *self {\n+            IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail), .. } =>",
        "path": "src/libstd/io/mod.rs",
        "position": null,
        "original_position": 29,
        "commit_id": "5ae6e93a0ef345a26426f60eecaf1448446d72eb",
        "original_commit_id": "72f3b20660f7e7f1113dd27258f80f23dd82dd1e",
        "user": {
            "login": "wycats",
            "id": 4,
            "node_id": "MDQ6VXNlcjQ=",
            "avatar_url": "https://avatars0.githubusercontent.com/u/4?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wycats",
            "html_url": "https://github.com/wycats",
            "followers_url": "https://api.github.com/users/wycats/followers",
            "following_url": "https://api.github.com/users/wycats/following{/other_user}",
            "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wycats/subscriptions",
            "organizations_url": "https://api.github.com/users/wycats/orgs",
            "repos_url": "https://api.github.com/users/wycats/repos",
            "events_url": "https://api.github.com/users/wycats/events{/privacy}",
            "received_events_url": "https://api.github.com/users/wycats/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Heh, good call!\n",
        "created_at": "2014-06-06T07:44:42Z",
        "updated_at": "2014-06-06T22:48:56Z",
        "html_url": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479328",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/14629",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/13479328"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/14629#discussion_r13479328"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/14629"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/10642854",
        "pull_request_review_id": null,
        "id": 10642854,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjQyODU0",
        "diff_hunk": "@@ -106,6 +110,7 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n     }\n }\n \n+#[doc(hidden)]",
        "path": "src/libterm/lib.rs",
        "position": null,
        "original_position": 25,
        "commit_id": "a6c14dda21d2ad87c4ab88c67196260192977c27",
        "original_commit_id": "cb706da63aa5d26dd94668c4ec7def2eeab3eb96",
        "user": {
            "login": "olleolleolle",
            "id": 211,
            "node_id": "MDQ6VXNlcjIxMQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/211?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/olleolleolle",
            "html_url": "https://github.com/olleolleolle",
            "followers_url": "https://api.github.com/users/olleolleolle/followers",
            "following_url": "https://api.github.com/users/olleolleolle/following{/other_user}",
            "gists_url": "https://api.github.com/users/olleolleolle/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/olleolleolle/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/olleolleolle/subscriptions",
            "organizations_url": "https://api.github.com/users/olleolleolle/orgs",
            "repos_url": "https://api.github.com/users/olleolleolle/repos",
            "events_url": "https://api.github.com/users/olleolleolle/events{/privacy}",
            "received_events_url": "https://api.github.com/users/olleolleolle/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I did not know how to do explain the \"all the fields of this are priv\", yet the main thing is not, so a very short docstring, like `Wraps an output stream and its terminal settings` may do the trick. \n\nThanks for picking this piece of lint.\n",
        "created_at": "2014-03-17T00:02:18Z",
        "updated_at": "2014-03-24T11:16:35Z",
        "html_url": "https://github.com/rust-lang/rust/pull/12948#discussion_r10642854",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/12948",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/10642854"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/12948#discussion_r10642854"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/12948"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/10642860",
        "pull_request_review_id": null,
        "id": 10642860,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjQyODYw",
        "diff_hunk": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Terminfo database interface.\n+\n #[allow(missing_doc)];",
        "path": "src/libterm/terminfo/mod.rs",
        "position": null,
        "original_position": 6,
        "commit_id": "a6c14dda21d2ad87c4ab88c67196260192977c27",
        "original_commit_id": "cb706da63aa5d26dd94668c4ec7def2eeab3eb96",
        "user": {
            "login": "olleolleolle",
            "id": 211,
            "node_id": "MDQ6VXNlcjIxMQ==",
            "avatar_url": "https://avatars0.githubusercontent.com/u/211?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/olleolleolle",
            "html_url": "https://github.com/olleolleolle",
            "followers_url": "https://api.github.com/users/olleolleolle/followers",
            "following_url": "https://api.github.com/users/olleolleolle/following{/other_user}",
            "gists_url": "https://api.github.com/users/olleolleolle/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/olleolleolle/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/olleolleolle/subscriptions",
            "organizations_url": "https://api.github.com/users/olleolleolle/orgs",
            "repos_url": "https://api.github.com/users/olleolleolle/repos",
            "events_url": "https://api.github.com/users/olleolleolle/events{/privacy}",
            "received_events_url": "https://api.github.com/users/olleolleolle/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I jiggled around with different wordings, placing them in different spots, to see what the generated docs did. This configuration made each sub-level print a description. Less is more, of course.\n",
        "created_at": "2014-03-17T00:03:44Z",
        "updated_at": "2014-03-24T11:16:35Z",
        "html_url": "https://github.com/rust-lang/rust/pull/12948#discussion_r10642860",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/12948",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/10642860"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/12948#discussion_r10642860"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/12948"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/4714758",
        "pull_request_review_id": null,
        "id": 4714758,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ3NTg=",
        "diff_hunk": "@@ -23,144 +24,246 @@ enum States {\n     CharConstant,\n     CharClose,\n     IntConstant,\n-    IfCond,\n-    IfBody\n+    SeekIfElse(int),\n+    SeekIfElsePercent(int),\n+    SeekIfEnd(int),\n+    SeekIfEndPercent(int)\n }\n \n /// Types of parameters a capability can use\n pub enum Param {\n     String(~str),\n-    Char(char),\n     Number(int)\n }\n \n+/// Container for static and dynamic variable arrays\n+pub struct Variables {\n+    /// Static variables A-Z\n+    sta: [Param, ..26],\n+    /// Dynamic variables a-z\n+    dyn: [Param, ..26]\n+}\n+\n+impl Variables {\n+    /// Return a new zero-initialized Variables\n+    pub fn new() -> Variables {\n+        Variables{ sta: [Number(0), ..26], dyn: [Number(0), ..26] }\n+    }\n+}\n+\n /**\n   Expand a parameterized capability\n \n   # Arguments\n   * `cap`    - string to expand\n   * `params` - vector of params for %p1 etc\n-  * `sta`    - vector of params corresponding to static variables\n-  * `dyn`    - vector of params corresponding to stativ variables\n+  * `vars`   - Variables struct for %Pa etc\n \n-  To be compatible with ncurses, `sta` and `dyn` should be the same between calls to `expand` for\n+  To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n   multiple capabilities for the same terminal.\n   */\n-pub fn expand(cap: &[u8], params: &mut [Param], sta: &mut [Param], dyn: &mut [Param])\n+pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     -> Result<~[u8], ~str> {\n-    assert!(cap.len() != 0, \"expanding an empty capability makes no sense\");\n-    assert!(params.len() <= 9, \"only 9 parameters are supported by capability strings\");\n-\n-    assert!(sta.len() <= 26, \"only 26 static vars are able to be used by capability strings\");\n-    assert!(dyn.len() <= 26, \"only 26 dynamic vars are able to be used by capability strings\");\n-\n     let mut state = Nothing;\n-    let mut i = 0;\n \n-    // expanded cap will only rarely be smaller than the cap itself\n+    // expanded cap will only rarely be larger than the cap itself\n     let mut output = vec::with_capacity(cap.len());\n \n-    let mut cur;\n-\n     let mut stack: ~[Param] = ~[];\n \n     let mut intstate = ~[];\n \n-    while i < cap.len() {\n-        cur = cap[i] as char;\n+    // Copy parameters into a local vector for mutability\n+    let mut mparams = [Number(0), ..9];\n+    for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n+        *dst = src;\n+    }\n+\n+    for cap.iter().transform(|&x| x).advance |c| {\n+        let cur = c as char;\n         let mut old_state = state;\n         match state {\n             Nothing => {\n                 if cur == '%' {\n                     state = Percent;\n                 } else {\n-                    output.push(cap[i]);\n+                    output.push(c);\n                 }\n             },\n             Percent => {\n                 match cur {\n-                    '%' => { output.push(cap[i]); state = Nothing },\n-                    'c' => match stack.pop() {\n-                        Char(c) => output.push(c as u8),\n-                        _       => return Err(~\"a non-char was used with %c\")\n-                    },\n-                    's' => match stack.pop() {\n-                        String(s) => output.push_all(s.as_bytes()),\n-                        _         => return Err(~\"a non-str was used with %s\")\n-                    },\n-                    'd' => match stack.pop() {\n-                        Number(x) => {\n-                            let s = x.to_str();\n-                            output.push_all(s.as_bytes())\n+                    '%' => { output.push(c); state = Nothing },\n+                    'c' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n+                            _       => return Err(~\"a non-char was used with %c\")\n                         }\n-                        _         => return Err(~\"a non-number was used with %d\")\n-                    },\n+                    } else { return Err(~\"stack is empty\") },\n+                    's' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => output.push_all(s.as_bytes()),\n+                            _         => return Err(~\"a non-str was used with %s\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'd' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => {\n+                                let s = x.to_str();\n+                                output.push_all(s.as_bytes())\n+                            }\n+                            _         => return Err(~\"a non-number was used with %d\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant,\n-                    'l' => match stack.pop() {\n-                        String(s) => stack.push(Number(s.len() as int)),\n-                        _         => return Err(~\"a non-str was used with %l\")\n-                    },\n-                    '+' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x + y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with +\")\n-                    },\n-                    '-' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x - y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with -\")\n-                    },\n-                    '*' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x * y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with *\")\n-                    },\n-                    '/' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x / y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with /\")\n-                    },\n-                    'm' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x % y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with %\")\n-                    },\n-                    '&' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x & y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with &\")\n-                    },\n-                    '|' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x | y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with |\")\n-                    },\n-                    'A' => return Err(~\"logical operations unimplemented\"),\n-                    'O' => return Err(~\"logical operations unimplemented\"),\n-                    '!' => return Err(~\"logical operations unimplemented\"),\n-                    '~' => match stack.pop() {\n-                        Number(x) => stack.push(Number(!x)),\n-                        _         => return Err(~\"non-number on stack with %~\")\n-                    },\n-                    'i' => match (copy params[0], copy params[1]) {\n-                        (Number(x), Number(y)) => {\n-                            params[0] = Number(x + 1);\n-                            params[1] = Number(y + 1);\n+                    'l' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => stack.push(Number(s.len() as int)),\n+                            _         => return Err(~\"a non-str was used with %l\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '+' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x + y)),\n+                            _ => return Err(~\"non-numbers on stack with +\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '-' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x - y)),\n+                            _ => return Err(~\"non-numbers on stack with -\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '*' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x * y)),\n+                            _ => return Err(~\"non-numbers on stack with *\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '/' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x / y)),\n+                            _ => return Err(~\"non-numbers on stack with /\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'm' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x % y)),\n+                            _ => return Err(~\"non-numbers on stack with %\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '&' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x & y)),\n+                            _ => return Err(~\"non-numbers on stack with &\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '|' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x | y)),\n+                            _ => return Err(~\"non-numbers on stack with |\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '^' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n+                            _ => return Err(~\"non-numbers on stack with ^\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '=' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with =\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '>' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with >\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '<' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with <\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'A' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(_)) => stack.push(Number(0)),\n+                            (Number(_), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical and\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'O' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical or\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '!' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => stack.push(Number(1)),\n+                            Number(_) => stack.push(Number(0)),\n+                            _ => return Err(~\"non-number on stack with logical not\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '~' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => stack.push(Number(!x)),\n+                            _         => return Err(~\"non-number on stack with %~\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'i' => match (copy mparams[0], copy mparams[1]) {",
        "path": "src/libextra/terminfo/parm.rs",
        "position": 289,
        "original_position": 289,
        "commit_id": "da4e614742ea67677ed122985c1730590748d788",
        "original_commit_id": "da4e614742ea67677ed122985c1730590748d788",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Hah, good point. I don't think the tests covered this case.\n",
        "created_at": "2013-06-15T20:30:27Z",
        "updated_at": "2013-06-15T20:30:27Z",
        "html_url": "https://github.com/rust-lang/rust/pull/7133#discussion_r4714758",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/7133",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/4714758"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/7133#discussion_r4714758"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/7133"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/4714841",
        "pull_request_review_id": null,
        "id": 4714841,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ4NDE=",
        "diff_hunk": "@@ -23,144 +24,246 @@ enum States {\n     CharConstant,\n     CharClose,\n     IntConstant,\n-    IfCond,\n-    IfBody\n+    SeekIfElse(int),\n+    SeekIfElsePercent(int),\n+    SeekIfEnd(int),\n+    SeekIfEndPercent(int)\n }\n \n /// Types of parameters a capability can use\n pub enum Param {\n     String(~str),\n-    Char(char),\n     Number(int)\n }\n \n+/// Container for static and dynamic variable arrays\n+pub struct Variables {\n+    /// Static variables A-Z\n+    sta: [Param, ..26],\n+    /// Dynamic variables a-z\n+    dyn: [Param, ..26]\n+}\n+\n+impl Variables {\n+    /// Return a new zero-initialized Variables\n+    pub fn new() -> Variables {\n+        Variables{ sta: [Number(0), ..26], dyn: [Number(0), ..26] }\n+    }\n+}\n+\n /**\n   Expand a parameterized capability\n \n   # Arguments\n   * `cap`    - string to expand\n   * `params` - vector of params for %p1 etc\n-  * `sta`    - vector of params corresponding to static variables\n-  * `dyn`    - vector of params corresponding to stativ variables\n+  * `vars`   - Variables struct for %Pa etc\n \n-  To be compatible with ncurses, `sta` and `dyn` should be the same between calls to `expand` for\n+  To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n   multiple capabilities for the same terminal.\n   */\n-pub fn expand(cap: &[u8], params: &mut [Param], sta: &mut [Param], dyn: &mut [Param])\n+pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     -> Result<~[u8], ~str> {\n-    assert!(cap.len() != 0, \"expanding an empty capability makes no sense\");\n-    assert!(params.len() <= 9, \"only 9 parameters are supported by capability strings\");\n-\n-    assert!(sta.len() <= 26, \"only 26 static vars are able to be used by capability strings\");\n-    assert!(dyn.len() <= 26, \"only 26 dynamic vars are able to be used by capability strings\");\n-\n     let mut state = Nothing;\n-    let mut i = 0;\n \n-    // expanded cap will only rarely be smaller than the cap itself\n+    // expanded cap will only rarely be larger than the cap itself\n     let mut output = vec::with_capacity(cap.len());\n \n-    let mut cur;\n-\n     let mut stack: ~[Param] = ~[];\n \n     let mut intstate = ~[];\n \n-    while i < cap.len() {\n-        cur = cap[i] as char;\n+    // Copy parameters into a local vector for mutability\n+    let mut mparams = [Number(0), ..9];\n+    for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n+        *dst = src;\n+    }\n+\n+    for cap.iter().transform(|&x| x).advance |c| {\n+        let cur = c as char;\n         let mut old_state = state;\n         match state {\n             Nothing => {\n                 if cur == '%' {\n                     state = Percent;\n                 } else {\n-                    output.push(cap[i]);\n+                    output.push(c);\n                 }\n             },\n             Percent => {\n                 match cur {\n-                    '%' => { output.push(cap[i]); state = Nothing },\n-                    'c' => match stack.pop() {\n-                        Char(c) => output.push(c as u8),\n-                        _       => return Err(~\"a non-char was used with %c\")\n-                    },\n-                    's' => match stack.pop() {\n-                        String(s) => output.push_all(s.as_bytes()),\n-                        _         => return Err(~\"a non-str was used with %s\")\n-                    },\n-                    'd' => match stack.pop() {\n-                        Number(x) => {\n-                            let s = x.to_str();\n-                            output.push_all(s.as_bytes())\n+                    '%' => { output.push(c); state = Nothing },\n+                    'c' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n+                            _       => return Err(~\"a non-char was used with %c\")\n                         }\n-                        _         => return Err(~\"a non-number was used with %d\")\n-                    },\n+                    } else { return Err(~\"stack is empty\") },\n+                    's' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => output.push_all(s.as_bytes()),\n+                            _         => return Err(~\"a non-str was used with %s\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'd' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => {\n+                                let s = x.to_str();\n+                                output.push_all(s.as_bytes())\n+                            }\n+                            _         => return Err(~\"a non-number was used with %d\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant,\n-                    'l' => match stack.pop() {\n-                        String(s) => stack.push(Number(s.len() as int)),\n-                        _         => return Err(~\"a non-str was used with %l\")\n-                    },\n-                    '+' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x + y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with +\")\n-                    },\n-                    '-' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x - y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with -\")\n-                    },\n-                    '*' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x * y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with *\")\n-                    },\n-                    '/' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x / y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with /\")\n-                    },\n-                    'm' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x % y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with %\")\n-                    },\n-                    '&' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x & y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with &\")\n-                    },\n-                    '|' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x | y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with |\")\n-                    },\n-                    'A' => return Err(~\"logical operations unimplemented\"),\n-                    'O' => return Err(~\"logical operations unimplemented\"),\n-                    '!' => return Err(~\"logical operations unimplemented\"),\n-                    '~' => match stack.pop() {\n-                        Number(x) => stack.push(Number(!x)),\n-                        _         => return Err(~\"non-number on stack with %~\")\n-                    },\n-                    'i' => match (copy params[0], copy params[1]) {\n-                        (Number(x), Number(y)) => {\n-                            params[0] = Number(x + 1);\n-                            params[1] = Number(y + 1);\n+                    'l' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => stack.push(Number(s.len() as int)),\n+                            _         => return Err(~\"a non-str was used with %l\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '+' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x + y)),\n+                            _ => return Err(~\"non-numbers on stack with +\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '-' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x - y)),\n+                            _ => return Err(~\"non-numbers on stack with -\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '*' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x * y)),\n+                            _ => return Err(~\"non-numbers on stack with *\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '/' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x / y)),\n+                            _ => return Err(~\"non-numbers on stack with /\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'm' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x % y)),\n+                            _ => return Err(~\"non-numbers on stack with %\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '&' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x & y)),\n+                            _ => return Err(~\"non-numbers on stack with &\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '|' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x | y)),\n+                            _ => return Err(~\"non-numbers on stack with |\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '^' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n+                            _ => return Err(~\"non-numbers on stack with ^\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '=' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with =\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '>' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with >\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '<' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n+                                                                        else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with <\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'A' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(_)) => stack.push(Number(0)),\n+                            (Number(_), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical and\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'O' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical or\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '!' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => stack.push(Number(1)),\n+                            Number(_) => stack.push(Number(0)),\n+                            _ => return Err(~\"non-number on stack with logical not\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '~' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => stack.push(Number(!x)),\n+                            _         => return Err(~\"non-number on stack with %~\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'i' => match (copy mparams[0], copy mparams[1]) {",
        "path": "src/libextra/terminfo/parm.rs",
        "position": 289,
        "original_position": 289,
        "commit_id": "da4e614742ea67677ed122985c1730590748d788",
        "original_commit_id": "da4e614742ea67677ed122985c1730590748d788",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I submitted #7160 to fix this\n",
        "created_at": "2013-06-15T21:25:15Z",
        "updated_at": "2013-06-15T21:25:15Z",
        "html_url": "https://github.com/rust-lang/rust/pull/7133#discussion_r4714841",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/7133",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/4714841"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/7133#discussion_r4714841"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/7133"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/4930796",
        "pull_request_review_id": null,
        "id": 4930796,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA3OTY=",
        "diff_hunk": "@@ -0,0 +1,204 @@\n+% Containers and iterators\n+\n+# Containers\n+\n+The container traits are defined in the `std::container` module.\n+\n+## Unique and managed vectors\n+\n+Vectors have `O(1)` indexing and removal from the end, along with `O(1)`\n+amortized insertion. Vectors are the most common container in Rust, and are\n+flexible enough to fit many use cases.\n+\n+Vectors can also be sorted and used as efficient lookup tables with the\n+`std::vec::bsearch` function, if all the elements are inserted at one time and\n+deletions are unnecessary.\n+\n+## Maps and sets\n+\n+Maps are collections of unique keys with corresponding values, and sets are\n+just unique keys without a corresponding value. The `Map` and `Set` traits in\n+`std::container` define the basic interface.\n+\n+The standard library provides three owned map/set types:\n+\n+* `std::hashmap::HashMap` and `std::hashmap::HashSet`, requiring the keys to\n+  implement `Eq` and `Hash`\n+* `std::trie::TrieMap` and `std::trie::TrieSet`, requiring the keys to be `uint`\n+* `extra::treemap::TreeMap` and `extra::treemap::TreeSet`, requiring the keys\n+  to implement `TotalOrd`\n+\n+These maps do not use managed pointers so they can be sent between tasks as\n+long as the key and value types are sendable. Neither the key or value type has\n+to be copyable.\n+\n+The `TrieMap` and `TreeMap` maps are ordered, and `HashMap` uses an arbitrary\n+order. Each `HashMap` a random 128-bit key passed along the key's keyed hash",
        "path": "doc/tutorial-container.md",
        "position": null,
        "original_position": 36,
        "commit_id": "cbe3549b29f12f57a95c184b440cd40636c8be1d",
        "original_commit_id": "9d45deaef9e569ed718e6b00eab645af5f571ca6",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This sentence seems broken\n",
        "created_at": "2013-06-28T01:03:44Z",
        "updated_at": "2013-06-28T01:08:27Z",
        "html_url": "https://github.com/rust-lang/rust/pull/7438#discussion_r4930796",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/7438",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/4930796"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/7438#discussion_r4930796"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/7438"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5544014",
        "pull_request_review_id": null,
        "id": 5544014,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQwMTQ=",
        "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::{os, uint};\n+\n+use sort;\n+\n+\n+/**\n+ * An iterator that yields Paths from the filesystem that match a particular\n+ * pattern - see the glob function for more details.\n+ */\n+pub struct GlobIterator {\n+    priv root: Path,\n+    priv dir_patterns: ~[~[PatternToken]],\n+    priv todo: ~[Path]\n+}\n+\n+enum PatternToken {\n+    Char(char),\n+    AnyChar,\n+    AnySequence,\n+    AnyWithin(~[char]),\n+    AnyExcept(~[char]),\n+}\n+\n+/**\n+ * Return an iterator that produces all the paths that match the given pattern,\n+ * which may be absolute or relative to the current working directory.\n+ *\n+ * This function accepts Unix shell style patterns:\n+ *   '?' matches any single character.\n+ *   '*' matches any (possibly empty) sequence of characters.\n+ *   '[...]' matches any character inside the brackets, unless the first character\n+ *           is '!' in which case it matches any character except those between\n+ *           the '!' and the ']'.\n+ *\n+ * The metacharacters '?', '*', '[', ']' can be matched by using brackets (e.g. '[?]')\n+ *\n+ * Paths are yielded in alphabetical order, as absolute paths.\n+ */\n+pub fn glob(pattern: &str) -> GlobIterator {\n+\n+    // note that this relies on the glob meta characters not\n+    // having any special meaning in actual pathnames\n+    let path = Path(pattern);\n+    let dir_patterns = path.components.map(|s| compile_pattern(*s));\n+\n+    let root = if path.is_absolute() {\n+        Path {components: ~[], .. path} // preserve windows path host/device\n+    } else {\n+        os::getcwd()\n+    };\n+    let todo = list_dir_sorted(&root);\n+\n+    GlobIterator {\n+        root: root,\n+        dir_patterns: dir_patterns,\n+        todo: todo,\n+    }\n+}\n+\n+impl Iterator<Path> for GlobIterator {\n+\n+    fn next(&mut self) -> Option<Path> {\n+        loop {\n+            if self.dir_patterns.is_empty() || self.todo.is_empty() {\n+                return None;\n+            }\n+\n+            let path = self.todo.pop();\n+            let pattern_index = path.components.len() - self.root.components.len() - 1;\n+\n+            if pattern_matches(*path.components.last(), self.dir_patterns[pattern_index]) {\n+\n+                if pattern_index == self.dir_patterns.len() - 1 {\n+                    // it is not possible for a pattern to match a directory *AND* its children\n+                    // so we don't need to check the children\n+                    return Some(path);\n+                } else {\n+                    self.todo.push_all(list_dir_sorted(&path));\n+                }\n+            }\n+        }\n+    }\n+\n+}\n+\n+fn list_dir_sorted(path: &Path) -> ~[Path] {\n+    let mut children = os::list_dir_path(path);\n+    sort::quick_sort(children, |p1, p2| p2.components.last() <= p1.components.last());\n+    children\n+}\n+\n+fn compile_pattern(pattern_str: &str) -> ~[PatternToken] {\n+    let mut pattern = ~[];\n+\n+    let mut pattern_iter = pattern_str.iter();\n+    loop {\n+        let pchar = match pattern_iter.next() {\n+            None => break,\n+            Some(c) => c,\n+        };\n+        match pchar {\n+            '?' => {\n+                pattern.push(AnyChar);\n+            }\n+            '*' => {\n+                pattern.push(AnySequence);\n+            }\n+            '[' => {\n+                let mut chars = ~[];\n+                let is_except = match pattern_iter.next() {\n+                    None => false, // let the following loop fail with a message",
        "path": "src/libextra/glob.rs",
        "position": null,
        "original_position": 122,
        "commit_id": "006b5e017ed2ab5f8d63984b86c8634c31e34905",
        "original_commit_id": "8a5a08e04d16678d9f843069a5fd28197a663619",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Unless things have changed in the past 2 weeks, the iterator contract does not require that an iterator that returns `None` once continue to return `None` forever. In fact, the iterator contract specifies nothing at all about the behavior after `None` has been returned once.\n",
        "created_at": "2013-08-01T23:40:46Z",
        "updated_at": "2013-08-18T20:08:45Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8201#discussion_r5544014",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8201",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5544014"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8201#discussion_r5544014"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8201"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5544045",
        "pull_request_review_id": null,
        "id": 5544045,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQwNDU=",
        "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::{os, uint};\n+\n+use sort;\n+\n+\n+/**\n+ * An iterator that yields Paths from the filesystem that match a particular\n+ * pattern - see the glob function for more details.\n+ */\n+pub struct GlobIterator {\n+    priv root: Path,\n+    priv dir_patterns: ~[~[PatternToken]],\n+    priv todo: ~[Path]\n+}\n+\n+enum PatternToken {\n+    Char(char),\n+    AnyChar,\n+    AnySequence,\n+    AnyWithin(~[char]),\n+    AnyExcept(~[char]),\n+}\n+\n+/**\n+ * Return an iterator that produces all the paths that match the given pattern,\n+ * which may be absolute or relative to the current working directory.\n+ *\n+ * This function accepts Unix shell style patterns:\n+ *   '?' matches any single character.\n+ *   '*' matches any (possibly empty) sequence of characters.\n+ *   '[...]' matches any character inside the brackets, unless the first character\n+ *           is '!' in which case it matches any character except those between\n+ *           the '!' and the ']'.\n+ *\n+ * The metacharacters '?', '*', '[', ']' can be matched by using brackets (e.g. '[?]')\n+ *\n+ * Paths are yielded in alphabetical order, as absolute paths.\n+ */\n+pub fn glob(pattern: &str) -> GlobIterator {\n+\n+    // note that this relies on the glob meta characters not\n+    // having any special meaning in actual pathnames\n+    let path = Path(pattern);\n+    let dir_patterns = path.components.map(|s| compile_pattern(*s));\n+\n+    let root = if path.is_absolute() {\n+        Path {components: ~[], .. path} // preserve windows path host/device\n+    } else {\n+        os::getcwd()\n+    };\n+    let todo = list_dir_sorted(&root);\n+\n+    GlobIterator {\n+        root: root,\n+        dir_patterns: dir_patterns,\n+        todo: todo,\n+    }\n+}\n+\n+impl Iterator<Path> for GlobIterator {\n+\n+    fn next(&mut self) -> Option<Path> {\n+        loop {\n+            if self.dir_patterns.is_empty() || self.todo.is_empty() {\n+                return None;\n+            }\n+\n+            let path = self.todo.pop();\n+            let pattern_index = path.components.len() - self.root.components.len() - 1;\n+\n+            if pattern_matches(*path.components.last(), self.dir_patterns[pattern_index]) {\n+\n+                if pattern_index == self.dir_patterns.len() - 1 {\n+                    // it is not possible for a pattern to match a directory *AND* its children\n+                    // so we don't need to check the children\n+                    return Some(path);\n+                } else {\n+                    self.todo.push_all(list_dir_sorted(&path));\n+                }\n+            }\n+        }\n+    }\n+\n+}\n+\n+fn list_dir_sorted(path: &Path) -> ~[Path] {\n+    let mut children = os::list_dir_path(path);\n+    sort::quick_sort(children, |p1, p2| p2.components.last() <= p1.components.last());\n+    children\n+}\n+\n+fn compile_pattern(pattern_str: &str) -> ~[PatternToken] {\n+    let mut pattern = ~[];\n+\n+    let mut pattern_iter = pattern_str.iter();\n+    loop {\n+        let pchar = match pattern_iter.next() {\n+            None => break,\n+            Some(c) => c,\n+        };\n+        match pchar {\n+            '?' => {\n+                pattern.push(AnyChar);\n+            }\n+            '*' => {\n+                pattern.push(AnySequence);\n+            }\n+            '[' => {\n+                let mut chars = ~[];\n+                let is_except = match pattern_iter.next() {\n+                    None => false, // let the following loop fail with a message\n+                    Some('!') => true,\n+                    Some(c) => {\n+                        chars.push(c);",
        "path": "src/libextra/glob.rs",
        "position": null,
        "original_position": 125,
        "commit_id": "006b5e017ed2ab5f8d63984b86c8634c31e34905",
        "original_commit_id": "8a5a08e04d16678d9f843069a5fd28197a663619",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "This code right here will allow me to write `[]]` to match `]`. However, I would expect `[!]]` to also work, and yet it won't. The `Some('!')` branch should probably proactively consume the next character.\n",
        "created_at": "2013-08-01T23:42:03Z",
        "updated_at": "2013-08-18T20:08:45Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8201#discussion_r5544045",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8201",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5544045"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8201#discussion_r5544045"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8201"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5566269",
        "pull_request_review_id": null,
        "id": 5566269,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjYyNjk=",
        "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::{os, uint};\n+\n+use sort;\n+\n+\n+/**\n+ * An iterator that yields Paths from the filesystem that match a particular\n+ * pattern - see the glob function for more details.\n+ */\n+pub struct GlobIterator {\n+    priv root: Path,\n+    priv dir_patterns: ~[~[PatternToken]],\n+    priv todo: ~[Path]\n+}\n+\n+enum PatternToken {\n+    Char(char),\n+    AnyChar,\n+    AnySequence,\n+    AnyWithin(~[char]),\n+    AnyExcept(~[char]),\n+}\n+\n+/**\n+ * Return an iterator that produces all the paths that match the given pattern,\n+ * which may be absolute or relative to the current working directory.\n+ *\n+ * This function accepts Unix shell style patterns:\n+ *   '?' matches any single character.\n+ *   '*' matches any (possibly empty) sequence of characters.\n+ *   '[...]' matches any character inside the brackets, unless the first character\n+ *           is '!' in which case it matches any character except those between\n+ *           the '!' and the ']'.\n+ *\n+ * The metacharacters '?', '*', '[', ']' can be matched by using brackets (e.g. '[?]')\n+ *\n+ * Paths are yielded in alphabetical order, as absolute paths.\n+ */\n+pub fn glob(pattern: &str) -> GlobIterator {\n+\n+    // note that this relies on the glob meta characters not\n+    // having any special meaning in actual pathnames\n+    let path = Path(pattern);\n+    let dir_patterns = path.components.map(|s| compile_pattern(*s));\n+\n+    let root = if path.is_absolute() {\n+        Path {components: ~[], .. path} // preserve windows path host/device\n+    } else {\n+        os::getcwd()\n+    };\n+    let todo = list_dir_sorted(&root);\n+\n+    GlobIterator {\n+        root: root,\n+        dir_patterns: dir_patterns,\n+        todo: todo,\n+    }\n+}\n+\n+impl Iterator<Path> for GlobIterator {\n+\n+    fn next(&mut self) -> Option<Path> {\n+        loop {\n+            if self.dir_patterns.is_empty() || self.todo.is_empty() {\n+                return None;\n+            }\n+\n+            let path = self.todo.pop();\n+            let pattern_index = path.components.len() - self.root.components.len() - 1;\n+\n+            if pattern_matches(*path.components.last(), self.dir_patterns[pattern_index]) {\n+\n+                if pattern_index == self.dir_patterns.len() - 1 {\n+                    // it is not possible for a pattern to match a directory *AND* its children\n+                    // so we don't need to check the children\n+                    return Some(path);\n+                } else {\n+                    self.todo.push_all(list_dir_sorted(&path));\n+                }\n+            }\n+        }\n+    }\n+\n+}\n+\n+fn list_dir_sorted(path: &Path) -> ~[Path] {\n+    let mut children = os::list_dir_path(path);\n+    sort::quick_sort(children, |p1, p2| p2.components.last() <= p1.components.last());\n+    children\n+}\n+\n+fn compile_pattern(pattern_str: &str) -> ~[PatternToken] {\n+    let mut pattern = ~[];\n+\n+    let mut pattern_iter = pattern_str.iter();\n+    loop {\n+        let pchar = match pattern_iter.next() {\n+            None => break,\n+            Some(c) => c,\n+        };\n+        match pchar {\n+            '?' => {\n+                pattern.push(AnyChar);\n+            }\n+            '*' => {\n+                pattern.push(AnySequence);\n+            }\n+            '[' => {\n+                let mut chars = ~[];\n+                let is_except = match pattern_iter.next() {\n+                    None => false, // let the following loop fail with a message",
        "path": "src/libextra/glob.rs",
        "position": null,
        "original_position": 122,
        "commit_id": "006b5e017ed2ab5f8d63984b86c8634c31e34905",
        "original_commit_id": "8a5a08e04d16678d9f843069a5fd28197a663619",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@Dretch After discussion with @thestinger it sounds like he wants the iterator protocol to actually state that once `None` is returned, future calls to `next()` will continue to return `None`.\n",
        "created_at": "2013-08-03T04:28:53Z",
        "updated_at": "2013-08-18T20:08:45Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8201#discussion_r5566269",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8201",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5566269"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8201#discussion_r5566269"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8201"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5596384",
        "pull_request_review_id": null,
        "id": 5596384,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTYzODQ=",
        "diff_hunk": "@@ -466,6 +466,56 @@ impl<T: Zero> Zero for ~T {\n     fn is_zero(&self) -> bool { (**self).is_zero() }\n }\n \n+/// Saturating math operations",
        "path": "src/libstd/num/num.rs",
        "position": 4,
        "original_position": 4,
        "commit_id": "3db3ce22f5a140d8ac4d992444b98d71de5ccb41",
        "original_commit_id": "2b3bd6e71013dce67ea56b029d826d5011470571",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I didn't like the idea of saying `a.saturating_add(b)`. Just seemed odd to me.\n",
        "created_at": "2013-08-06T04:16:50Z",
        "updated_at": "2013-08-06T05:49:39Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8323#discussion_r5596384",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8323",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5596384"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8323#discussion_r5596384"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8323"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5834918",
        "pull_request_review_id": null,
        "id": 5834918,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzQ5MTg=",
        "diff_hunk": "@@ -1504,6 +1522,9 @@ impl<A: Add<A, A> + Ord + Clone> Iterator<A> for Range<A> {\n             None\n         }\n     }\n+\n+    // FIXME: Implement size_hint()",
        "path": "src/libstd/iterator.rs",
        "position": null,
        "original_position": 87,
        "commit_id": "8741770471d08c78780fd6c22c18c0cf28fcf074",
        "original_commit_id": "1bae1d8b8ba2a2b940fb5a920237395196a58b2e",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh damn, so it does. I didn't realize.\n",
        "created_at": "2013-08-19T05:25:28Z",
        "updated_at": "2013-08-19T05:33:42Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8604#discussion_r5834918",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8604",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5834918"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8604#discussion_r5834918"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8604"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5835306",
        "pull_request_review_id": null,
        "id": 5835306,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzUzMDY=",
        "diff_hunk": "@@ -487,9 +528,21 @@ impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n             Some(fst)\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = self.v.len().div_rem(&self.size);",
        "path": "src/libstd/vec.rs",
        "position": 109,
        "original_position": 109,
        "commit_id": "8741770471d08c78780fd6c22c18c0cf28fcf074",
        "original_commit_id": "8741770471d08c78780fd6c22c18c0cf28fcf074",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`chunk_iter()` has `assert!(size != 0)`.\n",
        "created_at": "2013-08-19T06:20:04Z",
        "updated_at": "2013-08-19T06:20:04Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8604#discussion_r5835306",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8604",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/5835306"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8604#discussion_r5835306"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8604"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6078086",
        "pull_request_review_id": null,
        "id": 6078086,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzgwODY=",
        "diff_hunk": "@@ -37,6 +37,8 @@ use std::vec;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util;\n use syntax::{ast, ast_map};\n+use syntax::visit;\n+use syntax::visit::Visitor;",
        "path": "src/librustc/middle/trans/meth.rs",
        "position": null,
        "original_position": 5,
        "commit_id": "2c1d6568f253a2310a0b4a06064b2cf0271aa6be",
        "original_commit_id": "2bfbf9ee67f12138fc72841fedd104a6afca823d",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "`Visitor` isn't actually used; this line causes an unused-import error at stage1 compilation.\n",
        "created_at": "2013-08-30T01:40:29Z",
        "updated_at": "2013-08-30T01:51:34Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8843#discussion_r6078086",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8843",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6078086"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8843#discussion_r6078086"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8843"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6150418",
        "pull_request_review_id": null,
        "id": 6150418,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTA0MTg=",
        "diff_hunk": "@@ -57,54 +57,115 @@ pub fn PosixPath(s: &str) -> PosixPath {\n     GenericPath::from_str(s)\n }\n \n-pub trait GenericPath {\n-    /// Converts a string to a Path\n+pub trait GenericPath : Clone + Eq + ToStr {",
        "path": "src/libstd/path.rs",
        "position": 6,
        "original_position": 6,
        "commit_id": "59291eb197fad9a0fe3e94afda826f3abf1761ab",
        "original_commit_id": "072cad0d982f65f2b77812c4789db8f905874cfe",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I am. I'm pretty far along. I told @lkuper in IRC that refactoring to use default methods is fine and won't interfere with my work, but doing any more work on path is probably not a good idea as I'm replacing it entirely.\n\nI'm currently on vacation but I will be resuming my work on the new path next week.\n",
        "created_at": "2013-09-04T10:44:09Z",
        "updated_at": "2013-09-05T10:28:51Z",
        "html_url": "https://github.com/rust-lang/rust/pull/8909#discussion_r6150418",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/8909",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6150418"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/8909#discussion_r6150418"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/8909"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6399306",
        "pull_request_review_id": null,
        "id": 6399306,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkzMDY=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),\n+        Some(Ident{ident, span}) => {\n+            if ident.name == intern(\"little\") {\n+                true\n+            } else if ident.name == intern(\"big\") {\n+                false\n+            } else {\n+                cx.span_err(span, \"Invalid endian directive in fourcc!\");",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 39,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I based these error messages off of the ones that `bytes!()` produces. Is `bytes!()` is wrong?\n",
        "created_at": "2013-09-17T09:01:51Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6399306",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6399306"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6399306"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6399337",
        "pull_request_review_id": null,
        "id": 6399337,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkzMzc=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),\n+        Some(Ident{ident, span}) => {\n+            if ident.name == intern(\"little\") {\n+                true\n+            } else if ident.name == intern(\"big\") {\n+                false\n+            } else {\n+                cx.span_err(span, \"Invalid endian directive in fourcc!\");\n+                cfg!(target_endian = \"little\")\n+            }\n+        }\n+    };\n+\n+    let s = match expr.node {\n+        // expression is a literal\n+        ast::ExprLit(lit) => match lit.node {\n+            // string literal\n+            ast::lit_str(s) => {\n+                if !s.is_ascii() {\n+                    cx.span_err(expr.span, \"Non-ascii string literal in fourcc!\");\n+                } else if s.len() != 4 {\n+                    cx.span_err(expr.span, \"String literal with len != 4 in fourcc!\");\n+                }\n+                s\n+            }\n+            _ => cx.span_fatal(expr.span, \"Unsupported literal in fourcc!\")",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 57,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "The `span_fatal`s were mirroring `bytes!()`'s behavior here, as that's what I used to figure out how syntax extensions work. I assume you mean returning `cx.expr_unreachable()` as the return value of the entire function? So it would be something like\n\n```\n_ => {\n    cx.span_err(expr.span, \"blah\");\n    return MRExpr(cx.expr_unreachable());\n}\n```\n",
        "created_at": "2013-09-17T09:03:24Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6399337",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6399337"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6399337"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6399360",
        "pull_request_review_id": null,
        "id": 6399360,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTkzNjA=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),\n+        Some(Ident{ident, span}) => {\n+            if ident.name == intern(\"little\") {",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 34,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I like the `match`. I'll make that adjustment.\n",
        "created_at": "2013-09-17T09:04:15Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6399360",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6399360"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6399360"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415667",
        "pull_request_review_id": null,
        "id": 6415667,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTU2Njc=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),\n+        Some(Ident{ident, span}) => {\n+            if ident.name == intern(\"little\") {\n+                true\n+            } else if ident.name == intern(\"big\") {\n+                false\n+            } else {\n+                cx.span_err(span, \"Invalid endian directive in fourcc!\");",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 39,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "After looking at various `span_err`s, I think you're right.\n",
        "created_at": "2013-09-17T19:56:55Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415667",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415667"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415667"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415690",
        "pull_request_review_id": null,
        "id": 6415690,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTU2OTA=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),\n+        Some(Ident{ident, span}) => {\n+            if ident.name == intern(\"little\") {\n+                true\n+            } else if ident.name == intern(\"big\") {\n+                false\n+            } else {\n+                cx.span_err(span, \"Invalid endian directive in fourcc!\");\n+                cfg!(target_endian = \"little\")\n+            }\n+        }\n+    };\n+\n+    let s = match expr.node {\n+        // expression is a literal\n+        ast::ExprLit(lit) => match lit.node {\n+            // string literal\n+            ast::lit_str(s) => {\n+                if !s.is_ascii() {\n+                    cx.span_err(expr.span, \"Non-ascii string literal in fourcc!\");\n+                } else if s.len() != 4 {\n+                    cx.span_err(expr.span, \"String literal with len != 4 in fourcc!\");\n+                }\n+                s\n+            }\n+            _ => cx.span_fatal(expr.span, \"Unsupported literal in fourcc!\")",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 57,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I suspect it would probably be better to just return a `0u32` instead of `expr_unreachable`, in order to provide the correct type, but otherwise I agree.\n",
        "created_at": "2013-09-17T19:57:44Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415690",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415690"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415690"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415726",
        "pull_request_review_id": null,
        "id": 6415726,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTU3MjY=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 32,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "It is? Even though the name is `target_endian`? This is the same config value used by `unstable/intrinsics` in its byte-swapping wrappers.\n",
        "created_at": "2013-09-17T19:58:39Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415726",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415726"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415726"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415867",
        "pull_request_review_id": null,
        "id": 6415867,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTU4Njc=",
        "diff_hunk": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use codemap::{Span, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+use parse::token::intern;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => cfg!(target_endian = \"little\"),\n+        Some(Ident{ident, span}) => {\n+            if ident.name == intern(\"little\") {\n+                true\n+            } else if ident.name == intern(\"big\") {\n+                false\n+            } else {\n+                cx.span_err(span, \"Invalid endian directive in fourcc!\");\n+                cfg!(target_endian = \"little\")\n+            }\n+        }\n+    };\n+\n+    let s = match expr.node {\n+        // expression is a literal\n+        ast::ExprLit(lit) => match lit.node {\n+            // string literal\n+            ast::lit_str(s) => {\n+                if !s.is_ascii() {\n+                    cx.span_err(expr.span, \"Non-ascii string literal in fourcc!\");\n+                } else if s.len() != 4 {\n+                    cx.span_err(expr.span, \"String literal with len != 4 in fourcc!\");\n+                }\n+                s\n+            }\n+            _ => cx.span_fatal(expr.span, \"Unsupported literal in fourcc!\")\n+        },\n+        _ => cx.span_fatal(expr.span, \"Non-literal in fourcc!\")\n+    };\n+\n+    let mut bytes = [0u8, ..4];\n+    if little == cfg!(target_endian = \"little\") {\n+        for (byte, dst) in s.byte_iter().zip(bytes.mut_iter()) {\n+            *dst = byte;\n+        }\n+    } else {\n+        for (byte, dst) in s.byte_iter().zip(bytes.mut_rev_iter()) {\n+            *dst = byte;\n+        }\n+    }\n+    let val: u32 = unsafe { *bytes.as_imm_buf(|p,_| p as *u32) };",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 72,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "d6e5379c5077b22ebd0e64d8168edba0c6b942f4",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Fair enough.\n",
        "created_at": "2013-09-17T20:03:23Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415867",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6415867"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6415867"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6420810",
        "pull_request_review_id": null,
        "id": 6420810,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjA4MTA=",
        "diff_hunk": "@@ -0,0 +1,107 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* The compiler code necessary to support the fourcc! extension. */\n+\n+// fourcc!() is called with a single 4-character string, and an optional ident\n+// that is either `big` or `little`. If the ident is omitted it is assumed to\n+// be the platform-native value. It returns a u32.\n+\n+use ast;\n+use attr::contains;\n+use codemap::{Span, Spanned, mk_sp};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use parse;\n+use parse::token;\n+\n+use std::ascii::AsciiCast;\n+\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+    let (expr, endian) = parse_tts(cx, tts);\n+\n+    let little = match endian {\n+        None => target_endian_little(cx, sp),\n+        Some(Ident{ident, span}) => match cx.str_of(ident).as_slice() {\n+            \"little\" => true,\n+            \"big\" => false,\n+            _ => {\n+                cx.span_err(span, \"invalid endian directive in fourcc!\");\n+                target_endian_little(cx, sp)\n+            }\n+        }\n+    };\n+\n+    let s = match expr.node {\n+        // expression is a literal\n+        ast::ExprLit(lit) => match lit.node {\n+            // string literal\n+            ast::lit_str(s) => {\n+                if !s.is_ascii() {\n+                    cx.span_err(expr.span, \"non-ascii string literal in fourcc!\");\n+                } else if s.len() != 4 {\n+                    cx.span_err(expr.span, \"string literal with len != 4 in fourcc!\");\n+                }\n+                s\n+            }\n+            _ => {\n+                cx.span_err(expr.span, \"unsupported literal in fourcc!\");\n+                return MRExpr(cx.expr_lit(sp, ast::lit_uint(0u64, ast::ty_u32)));\n+            }\n+        },\n+        _ => {\n+            cx.span_err(expr.span, \"non-literal in fourcc!\");\n+            return MRExpr(cx.expr_lit(sp, ast::lit_uint(0u64, ast::ty_u32)));\n+        }\n+    };\n+\n+    let mut val = 0u32;\n+    if little {\n+        for byte in s.byte_rev_iter().take(4) {\n+            val = (val << 8) | (byte as u32);\n+        }\n+    } else {\n+        for byte in s.byte_iter().take(4) {\n+            val = (val << 8) | (byte as u32);\n+        }\n+    }\n+    let e = cx.expr_lit(sp, ast::lit_uint(val as u64, ast::ty_u32));\n+    MRExpr(e)\n+}\n+\n+struct Ident {\n+    ident: ast::Ident,\n+    span: Span\n+}\n+\n+fn parse_tts(cx: @ExtCtxt, tts: &[ast::token_tree]) -> (@ast::Expr, Option<Ident>) {\n+    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_owned());\n+    let ex = p.parse_expr();\n+    let id = if *p.token == token::EOF {\n+        None\n+    } else {\n+        p.expect(&token::COMMA);\n+        let lo = p.span.lo;\n+        let ident = p.parse_ident();\n+        let hi = p.last_span.hi;\n+        Some(Ident{ident: ident, span: mk_sp(lo, hi)})\n+    };\n+    if *p.token != token::EOF {\n+        p.unexpected();\n+    }\n+    (ex, id)\n+}\n+\n+fn target_endian_little(cx: @ExtCtxt, sp: Span) -> bool {\n+    let lit = Spanned{node: ast::lit_str(@\"little\"), span: sp};\n+    let meta = @Spanned{node: ast::MetaNameValue(@\"target_endian\", lit), span: sp};",
        "path": "src/libsyntax/ext/fourcc.rs",
        "position": null,
        "original_position": 105,
        "commit_id": "10ab68fb33f7883b9fc609453f6e910868f19f94",
        "original_commit_id": "9fbb66e2537c6aa22e2e9940845d7dca80bf13dc",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh, that's a lot simpler.\n",
        "created_at": "2013-09-17T23:02:05Z",
        "updated_at": "2013-09-25T20:48:24Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9255#discussion_r6420810",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9255",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6420810"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9255#discussion_r6420810"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9255"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6447781",
        "pull_request_review_id": null,
        "id": 6447781,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0NDc3ODE=",
        "diff_hunk": "@@ -118,77 +119,172 @@ pub struct Opt {\n     aliases: ~[Opt],\n }\n \n-fn mkname(nm: &str) -> Name {\n-  if nm.len() == 1u {\n-      Short(nm.char_at(0u))\n-  } else {\n-      Long(nm.to_owned())\n-  }\n+/// Describes wether an option is given at all or has an value",
        "path": "src/libextra/getopts.rs",
        "position": null,
        "original_position": 41,
        "commit_id": "06d1dccf95a1566137528a489fc573a610316bcf",
        "original_commit_id": "f881b5266c7650a4e64ec6c22b845ff48c5c26f5",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "\"has a value\"\n",
        "created_at": "2013-09-18T21:37:33Z",
        "updated_at": "2013-09-19T08:32:31Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9267#discussion_r6447781",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9267",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6447781"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9267#discussion_r6447781"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9267"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6680248",
        "pull_request_review_id": null,
        "id": 6680248,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODAyNDg=",
        "diff_hunk": "@@ -1,1507 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Cross-platform file path handling\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use c_str::ToCStr;\n-use c_str;\n-use clone::Clone;\n-use cmp::Eq;\n-use container::Container;\n-use iter::{Iterator, range};\n-use libc;\n-use num;\n-use option::{None, Option, Some};\n-use str::{OwnedStr, Str, StrSlice, StrVector};\n-use to_str::ToStr;\n-use ascii::{AsciiCast, AsciiStr};\n-use vec::{Vector, OwnedVector, ImmutableVector, OwnedCopyableVector};\n-\n-#[cfg(windows)]\n-pub use Path = self::WindowsPath;\n-#[cfg(unix)]\n-pub use Path = self::PosixPath;\n-\n-#[deriving(Clone, Eq)]\n-pub struct WindowsPath {\n-    host: Option<~str>,\n-    device: Option<~str>,\n-    is_absolute: bool,\n-    components: ~[~str],\n-}\n-\n-pub fn WindowsPath(s: &str) -> WindowsPath {\n-    GenericPath::from_str(s)\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct PosixPath {\n-    is_absolute: bool,\n-    components: ~[~str],\n-}\n-\n-pub fn PosixPath(s: &str) -> PosixPath {\n-    GenericPath::from_str(s)\n-}\n-\n-pub trait GenericPath : Clone + Eq + ToStr {\n-    /// Converts a string to a path.\n-    fn from_str(&str) -> Self;\n-\n-    /// Returns the directory component of `self`, as a string.\n-    fn dirname(&self) -> ~str {\n-        let s = self.dir_path().to_str();\n-        match s.len() {\n-            0 => ~\".\",\n-            _ => s,\n-        }\n-    }\n-\n-    /// Returns the file component of `self`, as a string option.\n-    /// Returns None if `self` names a directory.\n-    fn filename<'a>(&'a self) -> Option<&'a str> {\n-        match self.components().len() {\n-            0 => None,\n-            n => Some(self.components()[n - 1].as_slice()),\n-        }\n-    }\n-\n-    /// Returns the stem of the file component of `self`, as a string option.\n-    /// The stem is the slice of a filename starting at 0 and ending just before\n-    /// the last '.' in the name.\n-    /// Returns None if `self` names a directory.\n-    fn filestem<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) => Some(f.slice_to(p)),\n-                    None => Some((*f)),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns the type of the file component of `self`, as a string option.\n-    /// The file type is the slice of a filename starting just after the last\n-    /// '.' in the name and ending at the last index in the filename.\n-    /// Returns None if `self` names a directory.\n-    fn filetype<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) if p < f.len() => Some(f.slice_from(p)),\n-                    _ => None,\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns a new path consisting of `self` with the parent directory component replaced\n-    /// with the given string.\n-    fn with_dirname(&self, (&str)) -> Self;\n-\n-    /// Returns a new path consisting of `self` with the file component replaced\n-    /// with the given string.\n-    fn with_filename(&self, (&str)) -> Self;\n-\n-    /// Returns a new path consisting of `self` with the file stem replaced\n-    /// with the given string.\n-    fn with_filestem(&self, s: &str) -> Self {\n-        match self.filetype() {\n-            None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(s.to_owned() + *t),\n-        }\n-    }\n-\n-    /// Returns a new path consisting of `self` with the file type replaced\n-    /// with the given string.\n-    fn with_filetype(&self, t: &str) -> Self {\n-        match (t.len(), self.filestem()) {\n-            (0, None)        => (*self).clone(),\n-            (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n-            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n-        }\n-    }\n-\n-    /// Returns the directory component of `self`, as a new path.\n-    /// If `self` has no parent, returns `self`.\n-    fn dir_path(&self) -> Self {\n-        match self.components().len() {\n-            0 => (*self).clone(),\n-            _ => self.pop(),\n-        }\n-    }\n-\n-    /// Returns the file component of `self`, as a new path.\n-    /// If `self` names a directory, returns the empty path.\n-    fn file_path(&self) -> Self;\n-\n-    /// Returns a new path whose parent directory is `self` and whose\n-    /// file component is the given string.\n-    fn push(&self, (&str)) -> Self;\n-\n-    /// Returns a new path consisting of the given path, made relative to `self`.\n-    fn push_rel(&self, other: &Self) -> Self {\n-        assert!(!other.is_absolute());\n-        self.push_many(other.components())\n-    }\n-\n-    /// Returns a new path consisting of the path given by the given vector\n-    /// of strings, relative to `self`.\n-    fn push_many<S: Str>(&self, (&[S])) -> Self;\n-\n-    /// Identical to `dir_path` except in the case where `self` has only one\n-    /// component. In this case, `pop` returns the empty path.\n-    fn pop(&self) -> Self;\n-\n-    /// The same as `push_rel`, except that the directory argument must not\n-    /// contain directory separators in any of its components.\n-    fn unsafe_join(&self, (&Self)) -> Self;\n-\n-    /// On Unix, always returns `false`. On Windows, returns `true` iff `self`'s\n-    /// file stem is one of: `con` `aux` `com1` `com2` `com3` `com4`\n-    /// `lpt1` `lpt2` `lpt3` `prn` `nul`.\n-    fn is_restricted(&self) -> bool;\n-\n-    /// Returns a new path that names the same file as `self`, without containing\n-    /// any '.', '..', or empty components. On Windows, uppercases the drive letter\n-    /// as well.\n-    fn normalize(&self) -> Self;\n-\n-    /// Returns `true` if `self` is an absolute path.\n-    fn is_absolute(&self) -> bool;\n-\n-    /// True if `self` is an ancestor of `other`.\n-    // See `test_is_ancestor_of` for examples.\n-    fn is_ancestor_of(&self, other: &Self) -> bool {\n-        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute(),\n-               self.components().len());\n-        self == other ||\n-            (!other.components().is_empty() &&\n-             !(self.components().is_empty() && !self.is_absolute()) &&\n-             self.is_ancestor_of(&other.pop()))\n-    }\n-\n-    /// Finds the relative path from one file to another.\n-    fn get_relative_to(&self, abs2: (&Self)) -> Self {\n-        assert!(self.is_absolute());\n-        assert!(abs2.is_absolute());\n-        let abs1 = self.normalize();\n-        let abs2 = abs2.normalize();\n-\n-        let split1: &[~str] = abs1.components();\n-        let split2: &[~str] = abs2.components();\n-        let len1 = split1.len();\n-        let len2 = split2.len();\n-        assert!(len1 > 0);\n-        assert!(len2 > 0);\n-\n-        let max_common_path = num::min(len1, len2) - 1;\n-        let mut start_idx = 0;\n-        while start_idx < max_common_path\n-            && split1[start_idx] == split2[start_idx] {\n-            start_idx += 1;\n-        }\n-\n-        let mut path: ~[~str] = ~[];\n-        for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n-\n-        path.push_all(split2.slice(start_idx, len2 - 1));\n-\n-        let mut result: Self = GenericPath::from_str(\".\");\n-        if !path.is_empty() {\n-            // Without this type hint, the typechecker doesn't seem to like it\n-            let p: Self = GenericPath::from_str(\"\");\n-            result = p.push_many(path);\n-        };\n-        result\n-    }\n-\n-\n-    /// Returns `true` iff `child` is a suffix of `parent`. See the test\n-    /// case for examples.\n-    fn is_parent_of(&self, child: &Self) -> bool {\n-        if !self.is_absolute() || child.is_absolute()\n-            || self.components().len() < child.components().len()\n-            || self.components().is_empty() {\n-            return false;\n-        }\n-        let child_components = child.components().len();\n-        let parent_components = self.components().len();\n-        let to_drop = self.components().len() - child_components;\n-        self.components().slice(to_drop, parent_components) == child.components()\n-    }\n-\n-    fn components<'a>(&'a self) -> &'a [~str];\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-mod stat {\n-    #[cfg(target_arch = \"x86\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                __pad1: 0,\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                __pad2: 0,\n-                st_size: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                __unused4: 0,\n-                __unused5: 0,\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"arm\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                __pad0: [0, ..4],\n-                __st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                __pad3: [0, ..4],\n-                st_size: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_ino: 0\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"mips\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_pad1: [0, ..3],\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_pad2: [0, ..2],\n-                st_size: 0,\n-                st_pad3: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_pad5: [0, ..14],\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_ino: 0,\n-                st_nlink: 0,\n-                st_mode: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                __pad0: 0,\n-                st_rdev: 0,\n-                st_size: 0,\n-                st_blksize: 0,\n-                st_blocks: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                __unused: [0, 0, 0],\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-mod stat {\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_size: 0,\n-                st_blocks: 0,\n-                st_blksize: 0,\n-                st_flags: 0,\n-                st_gen: 0,\n-                st_lspare: 0,\n-                st_birthtime: 0,\n-                st_birthtime_nsec: 0,\n-                __unused: [0, 0],\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-mod stat {\n-    pub mod arch {\n-        use libc;\n-\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_ino: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_atime: 0,\n-                st_atime_nsec: 0,\n-                st_mtime: 0,\n-                st_mtime_nsec: 0,\n-                st_ctime: 0,\n-                st_ctime_nsec: 0,\n-                st_birthtime: 0,\n-                st_birthtime_nsec: 0,\n-                st_size: 0,\n-                st_blocks: 0,\n-                st_blksize: 0,\n-                st_flags: 0,\n-                st_gen: 0,\n-                st_lspare: 0,\n-                st_qspare: [0, 0],\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-mod stat {\n-    pub mod arch {\n-        use libc;\n-        pub fn default_stat() -> libc::stat {\n-            libc::stat {\n-                st_dev: 0,\n-                st_ino: 0,\n-                st_mode: 0,\n-                st_nlink: 0,\n-                st_uid: 0,\n-                st_gid: 0,\n-                st_rdev: 0,\n-                st_size: 0,\n-                st_atime: 0,\n-                st_mtime: 0,\n-                st_ctime: 0,\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-impl WindowsPath {\n-    pub fn stat(&self) -> Option<libc::stat> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do self.with_c_str |buf| {\n-            let mut st = stat::arch::default_stat();\n-            match unsafe { libc::stat(buf, &mut st) } {\n-                0 => Some(st),\n-                _ => None,\n-            }\n-        }\n-    }\n-\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true,\n-        }\n-    }\n-\n-    pub fn get_size(&self) -> Option<i64> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_size as i64),\n-        }\n-    }\n-\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_mode as uint),\n-        }\n-    }\n-}\n-\n-#[cfg(not(target_os = \"win32\"))]\n-impl PosixPath {\n-    pub fn stat(&self) -> Option<libc::stat> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do self.with_c_str |buf| {\n-            let mut st = stat::arch::default_stat();\n-            match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n-                0 => Some(st),\n-                _ => None,\n-            }\n-        }\n-    }\n-\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true,\n-        }\n-    }\n-\n-    pub fn get_size(&self) -> Option<i64> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_size as i64),\n-        }\n-    }\n-\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => Some(st.st_mode as uint),\n-        }\n-    }\n-\n-    /// Executes a function `f` on `self` as well as on all of its ancestors.\n-    pub fn each_parent(&self, f: &fn(&Path)) {\n-        if !self.components.is_empty() {\n-            f(self);\n-            self.pop().each_parent(f);\n-        }\n-    }\n-\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-impl PosixPath {\n-    pub fn get_atime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_atime as i64,\n-                      st.st_atime_nsec as int))\n-            }\n-        }\n-    }\n-\n-    pub fn get_mtime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_mtime as i64,\n-                      st.st_mtime_nsec as int))\n-            }\n-        }\n-    }\n-\n-    pub fn get_ctime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_ctime as i64,\n-                      st.st_ctime_nsec as int))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-impl PosixPath {\n-    pub fn lstat(&self) -> Option<libc::stat> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do self.with_c_str |buf| {\n-            let mut st = stat::arch::default_stat();\n-            match unsafe { libc::lstat(buf, &mut st) } {\n-                0 => Some(st),\n-                _ => None,\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"macos\")]\n-impl PosixPath {\n-    pub fn get_birthtime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_birthtime as i64,\n-                      st.st_birthtime_nsec as int))\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-impl WindowsPath {\n-    pub fn get_atime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_atime as i64, 0))\n-            }\n-        }\n-    }\n-\n-    pub fn get_mtime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_mtime as i64, 0))\n-            }\n-        }\n-    }\n-\n-    pub fn get_ctime(&self) -> Option<(i64, int)> {\n-        match self.stat() {\n-            None => None,\n-            Some(ref st) => {\n-                Some((st.st_ctime as i64, 0))\n-            }\n-        }\n-    }\n-\n-    /// Executes a function `f` on `self` as well as on all of its ancestors.\n-    pub fn each_parent(&self, f: &fn(&Path)) {\n-        if !self.components.is_empty() {\n-            f(self);\n-            self.pop().each_parent(f);\n-        }\n-    }\n-}\n-\n-impl ToStr for PosixPath {\n-    fn to_str(&self) -> ~str {\n-        let mut s = ~\"\";\n-        if self.is_absolute {\n-            s.push_str(\"/\");\n-        }\n-        s + self.components.connect(\"/\")\n-    }\n-}\n-\n-impl ToCStr for PosixPath {\n-    fn to_c_str(&self) -> c_str::CString {\n-        self.to_str().to_c_str()\n-    }\n-\n-    unsafe fn to_c_str_unchecked(&self) -> c_str::CString {\n-        self.to_str().to_c_str_unchecked()\n-    }\n-}\n-\n-impl GenericPath for PosixPath {\n-    fn from_str(s: &str) -> PosixPath {\n-        let components = s.split_iter('/')\n-            .filter_map(|s| if s.is_empty() {None} else {Some(s.to_owned())})\n-            .collect();\n-        let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n-        PosixPath {\n-            is_absolute: is_absolute,\n-            components: components,\n-        }\n-    }\n-\n-    fn with_dirname(&self, d: &str) -> PosixPath {\n-        let dpath = PosixPath(d);\n-        match self.filename() {\n-            Some(ref f) => dpath.push(*f),\n-            None => dpath,\n-        }\n-    }\n-\n-    fn with_filename(&self, f: &str) -> PosixPath {\n-        assert!(!f.iter().all(posix::is_sep));\n-        self.dir_path().push(f)\n-    }\n-\n-    fn file_path(&self) -> PosixPath {\n-        let cs = match self.filename() {\n-          None => ~[],\n-          Some(ref f) => ~[(*f).to_owned()]\n-        };\n-        PosixPath {\n-            is_absolute: false,\n-            components: cs,\n-        }\n-    }\n-\n-    fn push(&self, s: &str) -> PosixPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(posix::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        PosixPath {\n-            components: v,\n-            ..(*self).clone()\n-        }\n-    }\n-\n-    fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n-        let mut v = self.components.clone();\n-        for e in cs.iter() {\n-            for s in e.as_slice().split_iter(posix::is_sep) {\n-                if !s.is_empty() {\n-                    v.push(s.to_owned())\n-                }\n-            }\n-        }\n-        PosixPath {\n-            is_absolute: self.is_absolute,\n-            components: v,\n-        }\n-    }\n-\n-    fn pop(&self) -> PosixPath {\n-        let mut cs = self.components.clone();\n-        if cs.len() != 0 {\n-            cs.pop();\n-        }\n-        PosixPath {\n-            is_absolute: self.is_absolute,\n-            components: cs,\n-        } //..self }\n-    }\n-\n-    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n-        if other.is_absolute {\n-            PosixPath {\n-                is_absolute: true,\n-                components: other.components.clone(),\n-            }\n-        } else {\n-            self.push_rel(other)\n-        }\n-    }\n-\n-    fn is_restricted(&self) -> bool {\n-        false\n-    }\n-\n-    fn normalize(&self) -> PosixPath {\n-        PosixPath {\n-            is_absolute: self.is_absolute,\n-            components: normalize(self.components),\n-        } // ..self }\n-    }\n-\n-    fn is_absolute(&self) -> bool {\n-        self.is_absolute\n-    }\n-\n-    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n-\n-}\n-\n-\n-impl ToStr for WindowsPath {\n-    fn to_str(&self) -> ~str {",
        "path": "src/libstd/path.rs",
        "position": 773,
        "original_position": 773,
        "commit_id": "d108a22fd1b38c108e2b9b6cd7276d953524ffa2",
        "original_commit_id": "867d54cc994d83c6b8b98c70580dfe1d7c933c21",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "@alexcrichton Nearly all of those locations have a `// FIXME` to make it so we don't need to do that. Almost all of those will hopefully become `.as_vec()` as other parts of the system become aware of non-utf8 paths. I intentionally left it awkward to convert to a `~str` because I want to discourage unnecessary allocation.\n\nBesides, I can't impl `ToStr`. At best I could have a `.to_str() -> Option<~str>` but that's not great.\n",
        "created_at": "2013-10-01T08:04:11Z",
        "updated_at": "2013-10-16T18:19:08Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9655#discussion_r6680248",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9655",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6680248"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9655#discussion_r6680248"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9655"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6696455",
        "pull_request_review_id": null,
        "id": 6696455,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTY0NTU=",
        "diff_hunk": "@@ -80,18 +80,32 @@ pub fn glob(pattern: &str) -> GlobIterator {\n  * Paths are yielded in alphabetical order, as absolute paths.\n  */\n pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n+    #[cfg(windows)]\n+    use is_sep = std::path::windows::is_sep2;\n+    #[cfg(not(windows))]\n+    fn is_sep(c: char) -> bool { ::std::path::posix::is_sep(&(c as u8)) }",
        "path": "src/libextra/glob.rs",
        "position": null,
        "original_position": 16,
        "commit_id": "d108a22fd1b38c108e2b9b6cd7276d953524ffa2",
        "original_commit_id": "867d54cc994d83c6b8b98c70580dfe1d7c933c21",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "Oh damn. I was thinking about this as if I was truncating a UTF-8 sequence down to one byte, but that's clearly not correct. I've used the same pattern of `c as u8` elsewhere, which I'll have to fix.\n",
        "created_at": "2013-10-01T19:24:30Z",
        "updated_at": "2013-10-16T18:19:08Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9655#discussion_r6696455",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9655",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6696455"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9655#discussion_r6696455"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9655"
            }
        }
    },
    {
        "url": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6696586",
        "pull_request_review_id": null,
        "id": 6696586,
        "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTY1ODY=",
        "diff_hunk": "@@ -80,18 +80,32 @@ pub fn glob(pattern: &str) -> GlobIterator {\n  * Paths are yielded in alphabetical order, as absolute paths.\n  */\n pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n+    #[cfg(windows)]\n+    use is_sep = std::path::windows::is_sep2;\n+    #[cfg(not(windows))]\n+    fn is_sep(c: char) -> bool { ::std::path::posix::is_sep(&(c as u8)) }\n+    #[cfg(windows)]\n+    fn check_windows_verbatim(p: &Path) -> bool { p.is_verbatim() }\n+    #[cfg(not(windows))]\n+    fn check_windows_verbatim(_: &Path) -> bool { false }\n+\n+    // calculate root this way to handle volume-relative Windows paths correctly\n+    let mut root = os::getcwd();\n+    let pat_root = Path::from_str(pattern).root_path();\n+    if pat_root.is_some() {\n+        if check_windows_verbatim(pat_root.get_ref()) {\n+            // A verbatim path looks like \\\\?\\foo, which is probably a bad glob.\n+            // We should yield nothing.",
        "path": "src/libextra/glob.rs",
        "position": null,
        "original_position": 28,
        "commit_id": "d108a22fd1b38c108e2b9b6cd7276d953524ffa2",
        "original_commit_id": "867d54cc994d83c6b8b98c70580dfe1d7c933c21",
        "user": {
            "login": "lilyball",
            "id": 714,
            "node_id": "MDQ6VXNlcjcxNA==",
            "avatar_url": "https://avatars3.githubusercontent.com/u/714?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lilyball",
            "html_url": "https://github.com/lilyball",
            "followers_url": "https://api.github.com/users/lilyball/followers",
            "following_url": "https://api.github.com/users/lilyball/following{/other_user}",
            "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions",
            "organizations_url": "https://api.github.com/users/lilyball/orgs",
            "repos_url": "https://api.github.com/users/lilyball/repos",
            "events_url": "https://api.github.com/users/lilyball/events{/privacy}",
            "received_events_url": "https://api.github.com/users/lilyball/received_events",
            "type": "User",
            "site_admin": false
        },
        "body": "I have no idea how glob is supposed to interact with special Windows paths. For example, if I type `?:\\foo\\bar` as my glob, is that supposed to match `C:\\foo\\bar`? Similarly `\\\\?\\foo\\bar` seems like either garbage, or like a glob that's supposed to match all UNC paths with a 1-letter server and a share called `foo`. The latter doesn't seem very doable.\n\nI think it's actually a mistake to try and parse glob patterns using `Path` to begin with. But I put in the verbatim check because I think the only reasonable expectation of a glob pattern `\\\\?\\foo` is to match UNC shares with a 1-letter server and a share of `foo`, and we can't actually implement that. Hence, an empty glob iterator.\n",
        "created_at": "2013-10-01T19:28:20Z",
        "updated_at": "2013-10-16T18:19:08Z",
        "html_url": "https://github.com/rust-lang/rust/pull/9655#discussion_r6696586",
        "pull_request_url": "https://api.github.com/repos/rust-lang/rust/pulls/9655",
        "author_association": "CONTRIBUTOR",
        "_links": {
            "self": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/comments/6696586"
            },
            "html": {
                "href": "https://github.com/rust-lang/rust/pull/9655#discussion_r6696586"
            },
            "pull_request": {
                "href": "https://api.github.com/repos/rust-lang/rust/pulls/9655"
            }
        }
    }
]